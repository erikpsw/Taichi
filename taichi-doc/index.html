

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>taichi 0.6.10 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="//media.readthedocs.org/css/sphinx_rtd_theme.css" type="text/css" />
  <link rel="stylesheet" href="//media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />
  <link rel="stylesheet" href="_static/extra.css" type="text/css" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html#document-index" class="icon icon-home"> taichi
          

          
          </a>

          
            
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><p class="caption"><span class="caption-text">概览</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-overview">为什么选择一门新的编程语言</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#design-decisions">设计决策</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-install">安装 Taichi</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#troubleshooting">故障排除</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#windows-issues">Windows 相关问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#python-issues">Python 相关问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#cuda-issues">CUDA 相关问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#opengl-issues">OpenGL 相关问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#linux-issues">Linux 相关问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#other-issues">其他相关问题</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-hello">你好，世界！</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#import-taichi-as-ti">import taichi as ti</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#portability">可移植性</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#sparse-tensors">（稀疏）张量</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#functions-and-kernels">函数与内核</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#parallel-for-loops">并行执行的for循环</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interacting-with-python">与 Python 交互</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">基本概念</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-syntax">语法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#kernels">内核</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#functions">函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#scalar-arithmetics">标量算术</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#debugging">调试</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-type">类型系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#supported-types">支持的类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#default-precisions">默认精度</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#type-casts">类型转换</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-tensor_matrix">张量与矩阵</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#tensors-of-scalars">由标量组成的张量</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#tensors-of-matrices">由矩阵组成的张量</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#matrix-size">矩阵大小</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-atomic">原子操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-external">与外部数组进行交互</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#conversion-between-taichi-tensors-and-external-arrays">Taichi张量与外部数组之间的转换</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#using-external-arrays-as-taichi-kernel-parameters">Using external arrays as Taichi kernel parameters</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">API 参考手册</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-scalar_tensor">标量组成的张量</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#declaration">定义</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#accessing-components">访问分量</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#meta-data">元数据</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-vector">向量</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#declaration">声明向量</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#as-global-tensors-of-vectors">全局张量中的向量</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#as-a-temporary-local-variable">临时局部变量向量</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#accessing-components">访问向量分量</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id1">全局张量中的向量</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id2">临时局部变量向量</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#methods">相关方法</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-matrix">矩阵</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#declaration">定义</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#as-global-tensors-of-matrices">作为全局张量的矩阵</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#as-a-temporary-local-variable">作为一个临时的本地变量</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#accessing-components">元素访问</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#as-global-tensors-of-vectors">作为全局的由向量构成的张量</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id1">作为一个临时的本地变量</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#methods">Methods</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-snode">结构节点 (SNodes)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#node-types">不同类型的节点</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#working-with-dynamic-snodes">动态集合节点的使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#taichi-tensors-like-powers-of-two">Taichi 的张量尺寸</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#indices">索引</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">高级编程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-meta">元编程</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#template-metaprogramming">Template metaprogramming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#dimensionality-independent-programming-using-grouped-indices">使用组合索引（grouped indices）的对维度不依赖的编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#tensor-size-reflection">张量尺寸的反射（size reflection）</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#compile-time-evaluations">编译时求值（Compile-time evaluations）</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#when-to-use-for-loops-with-ti-static">何时使用 <code class="docutils literal notranslate"><span class="pre">ti.static</span></code> 来进行for循环</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-layout">高级数据布局</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#from-shape-to-ti-root-x">由 <code class="docutils literal notranslate"><span class="pre">shape</span></code> 到 <code class="docutils literal notranslate"><span class="pre">ti.root.X</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#row-major-versus-column-major">行优先 vs 列优先</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#array-of-structures-aos-structure-of-arrays-soa">数组结构体(AoS)，结构体数组(SoA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#flat-layouts-versus-hierarchical-layouts">平面布局 vs 层次布局</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#struct-fors-on-advanced-dense-data-layouts">对高级稠密数据布局进行结构 for 循环</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#examples">示例</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-sparse">Sparse computation (WIP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-offset">坐标偏移</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-differentiable_programming">可微编程</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-odop">面向数据对象式编程</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-compilation">Taichi内核的生命周期</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#kernel-registration">内核注册</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#template-instantiation-and-caching">模板实例化和缓存</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-transformation-and-optimizations">代码转换和优化</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#the-just-in-time-jit-compilation-engine">即时(JIT)编译引擎</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#kernel-launching">内核启动</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-syntax_sugars">语法糖</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#aliases">别名</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-dev_install">开发者安装指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-contributor_guide">开发与贡献指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-utilities">开发者工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cpp_style">C++ 代码风格规范</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-internal">内部设计（WIP）</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-taichicon">Taichi 开发者讨论会</a></li>
</ul>
<p class="caption"><span class="caption-text">杂项</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-gui">GUI系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#create-a-window">创建一个窗口</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#paint-on-a-window">在窗口上作画</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#event-processing">事件处理</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#image-i-o">图片输入/输出</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cli_utilities">Command line utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#changelog">Changelog</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-export_results">导出结果</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#export-images">导出图像</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#export-images-using-ti-gui-show">通过 <code class="docutils literal notranslate"><span class="pre">ti.GUI.show</span></code> 导出图像</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#export-images-using-ti-imwrite">通过  <code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code> 导出图像</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#export-videos">导出视频</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#install-ffmpeg">安装 ffmpeg</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#install-ffmpeg-on-windows">在 Windows 上安装 ffmpeg</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#install-ffmpeg-on-linux">在 Linux 上安装 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#install-ffmpeg-on-os-x">在 OS X 上安装 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#export-ply-files">导出 PLY 文件</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#import-ply-files-into-houdini-and-blender">将 <code class="docutils literal notranslate"><span class="pre">ply</span></code> 文件导出到 Houdini 和 Blender</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-global_settings">全局设置</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#backends">后端</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#compilation">编译</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#runtime">运行</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#logging">日志记录</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#develop">开发</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-faq">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-acknowledgments">致谢</a></li>
</ul>
<p class="caption"><span class="caption-text">Legacy</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-legacy_installation">Installing the legacy Taichi Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#ubuntu-arch-linux-and-mac-os-x">Ubuntu, Arch Linux, and Mac OS X</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#windows">Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#build-with-double-precision-64-bit-float-point">Build with Double Precision (64 bit) Float Point</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html#document-index">taichi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html#document-index">Docs</a> &raquo;</li>
        
      <li>taichi 0.6.10 文档</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/taichi-dev/taichi-docs-zh-cn/blob/master/index.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-taichi-programming-language">
<h1>Taichi编程语言<a class="headerlink" href="#the-taichi-programming-language" title="永久链接至标题">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-overview"></span><div class="section" id="why-new-programming-language">
<h2>为什么选择一门新的编程语言<a class="headerlink" href="#why-new-programming-language" title="永久链接至标题">¶</a></h2>
<p>太极是一种用于计算机图形应用的高性能编程语言。其设计目标有：</p>
<ul class="simple">
<li>生产力</li>
<li>性能</li>
<li>可移植性</li>
<li>空间稀疏计算</li>
<li>可微编程</li>
<li>元编程</li>
</ul>
<div class="section" id="design-decisions">
<h3>设计决策<a class="headerlink" href="#design-decisions" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>解耦计算与数据结构</li>
<li>领域特定编译器优化</li>
<li>大核心</li>
<li>双尺度自动微分</li>
<li>嵌入Python</li>
</ul>
</div>
</div>
<span id="document-install"></span><div class="section" id="installation">
<h2>安装 Taichi<a class="headerlink" href="#installation" title="永久链接至标题">¶</a></h2>
<p>很容易通过 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 安装 Taichi :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3 -m pip install taichi
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">目前，Taichi 支持的 Python 版本有 3.6/3.7/3.8 (64-bit)。</p>
</div>
<ul class="simple">
<li>对于Ubuntu 19.04+，请执行 <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">apt</span> <span class="pre">install</span> <span class="pre">libtinfo5</span></code>  安装依赖项。</li>
<li>对于Arch Linux，请执行 <code class="docutils literal notranslate"><span class="pre">yaourt</span> <span class="pre">-S</span> <span class="pre">ncurses5-compat-libs</span></code> 安装依赖项。</li>
<li>对于 Windows，请预先安装运行组件库 <a class="reference external" href="https://aka.ms/vs/16/release/vc_redist.x64.exe">Microsoft Visual C++ Redistributable</a> .</li>
</ul>
<div class="section" id="troubleshooting">
<h3>故障排除<a class="headerlink" href="#troubleshooting" title="永久链接至标题">¶</a></h3>
<div class="section" id="windows-issues">
<h4>Windows 相关问题<a class="headerlink" href="#windows-issues" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>如果在 Windows下 Taichi 崩溃并报告 <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> ：请考虑安装运行组件库 <a class="reference external" href="https://aka.ms/vs/16/release/vc_redist.x64.exe">Microsoft Visual C++ Redistributable</a> 以进行解决.</li>
</ul>
</div>
<div class="section" id="python-issues">
<h4>Python 相关问题<a class="headerlink" href="#python-issues" title="永久链接至标题">¶</a></h4>
<ul>
<li><p class="first">如果 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 报错找不到合适的包，即,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ERROR: Could not find a version that satisfies the requirement taichi (from versions: none)
ERROR: No matching distribution found for taichi
</pre></div>
</div>
<ul>
<li><p class="first">确保你使用的 Python 版本是 3.6/3.7/3.8:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3 -c “print<span class="o">(</span>__import__<span class="o">(</span>‘sys’<span class="o">)</span>.version<span class="o">[</span>:3<span class="o">])</span>”
<span class="c1"># 3.6, 3.7 或 3.8</span>
</pre></div>
</div>
</li>
<li><p class="first">确保你安装的 Python 可执行文件是 64-bit:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3 -c <span class="s2">&quot;print(__import__(&#39;platform&#39;).architecture()[0])&quot;</span>
<span class="c1"># 64bit</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="cuda-issues">
<h4>CUDA 相关问题<a class="headerlink" href="#cuda-issues" title="永久链接至标题">¶</a></h4>
<ul>
<li><p class="first">如果 Taichi 报告以下崩溃信息:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[Taichi] mode=release
[Taichi] version 0.6.0, supported archs: [cpu, cuda, opengl], commit 14094f25, python 3.8.2
[W 05/14/20 10:46:49.549] [cuda_driver.h:call_with_warning@60] CUDA Error CUDA_ERROR_INVALID_DEVICE: invalid device ordinal while calling mem_advise (cuMemAdvise)
[E 05/14/20 10:46:49.911] Received signal 7 (Bus error)
</pre></div>
</div>
</div></blockquote>
<p>这可能是因为你使用的 NVIDIA GPU 低于 Pascal 架构，这对 <a class="reference external" href="https://www.nextplatform.com/2019/01/24/unified-memory-the-final-piece-of-the-gpu-programming-puzzle/">统一内存(Unified Memory)</a> 会有限制。</p>
<ul class="simple">
<li><strong>解决方案</strong>: 尝试添加 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_USE_UNIFIED_MEMORY=0</span></code> 到 <code class="docutils literal notranslate"><span class="pre">~/.bashrc</span></code> 。该操作将禁用CUDA后端使用统一内存。</li>
</ul>
</li>
<li><p class="first">如果你遇到了其他 CUDA 相关问题，不要气馁:</p>
<ul class="simple">
<li><strong>解决方案</strong>:尝试添加 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_ENABLE_CUDA=0</span></code> 到 <code class="docutils literal notranslate"><span class="pre">~/.bashrc</span></code> 。该操作将完全禁用CUDA后端，这样Taichi会依赖于其他GPU后端，如OpenGL。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="opengl-issues">
<h4>OpenGL 相关问题<a class="headerlink" href="#opengl-issues" title="永久链接至标题">¶</a></h4>
<ul>
<li><p class="first">针对 Taichi 打印出的调用栈(stack backtrace)中包含 <code class="docutils literal notranslate"><span class="pre">glfwCreateWindow</span></code> 等信息的情况(更详细的问题描述请对照 <a class="reference external" href="https://github.com/taichi-dev/taichi/issues/958">#958</a>):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[Taichi] mode=release
[E 05/12/20 18.25:00.129] Received signal 11 (Segmentation Fault)
***********************************
* Taichi Compiler Stack Traceback *
***********************************

... (many lines, omitted)

/lib/python3.8/site-packages/taichi/core/../lib/taichi_core.so: _glfwPlatformCreateWindow
/lib/python3.8/site-packages/taichi/core/../lib/taichi_core.so: glfwCreateWindow
/lib/python3.8/site-packages/taichi/core/../lib/taichi_core.so: taichi::lang::opengl::initialize_opengl(bool)

... (many lines, omitted)
</pre></div>
</div>
<p>这很可能是因为你运行 Taichi 的虚拟机上的 OpenGL 版本过低。Taichi 需要 OpenGL 4.3+ 才能工作。</p>
<ul class="simple">
<li><strong>解决方案</strong>: 尝试添加 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_ENABLE_OPENGL=0</span></code> 到 <code class="docutils literal notranslate"><span class="pre">~/.bashrc</span></code> 。该操作将禁用OpenGL后端检测，以避免OpenGL版本不兼容的问题。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="linux-issues">
<h4>Linux 相关问题<a class="headerlink" href="#linux-issues" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>如果 Taichi 崩溃并报告 <code class="docutils literal notranslate"><span class="pre">libtinfo.so.5</span> <span class="pre">not</span> <span class="pre">found</span></code> :那么请尝试在 Ubuntu 上安装 <code class="docutils literal notranslate"><span class="pre">libtinfo5</span></code> 或在 Arch Linux 上相应安装 <code class="docutils literal notranslate"><span class="pre">ncurses5-compat-libs</span></code> （Archlinux 用户社区的软件库，AUR）进行解决。</li>
</ul>
</div>
<div class="section" id="other-issues">
<h4>其他相关问题<a class="headerlink" href="#other-issues" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>如果以上都没能解决你的问题，请在 GitHub 上 <a class="reference external" href="https://github.com/taichi-dev/taichi/issues/new?labels=potential+bug&amp;template=bug_report.md">开个 issue</a> 进行报告。这将帮助我们后续提高用户体验和兼容性，非常感谢！</li>
</ul>
</div>
</div>
</div>
<span id="document-hello"></span><div class="section" id="hello-world">
<h2>你好，世界！<a class="headerlink" href="#hello-world" title="永久链接至标题">¶</a></h2>
<p>我们将通过一个分形程序的例子来介绍 Taichi。</p>
<p>Running the Taichi code below (<code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">fractal.py</span></code> or <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">example</span> <span class="pre">fractal</span></code>) will give you an animation of
<a class="reference external" href="https://en.wikipedia.org/wiki/Julia_set">Julia set</a>:</p>
<img alt="https://github.com/yuanming-hu/public_files/raw/master/graphics/taichi/fractal.gif" src="https://github.com/yuanming-hu/public_files/raw/master/graphics/taichi/fractal.gif" />
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># fractal.py</span>

<span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">gpu</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">320</span>
<span class="n">pixels</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<span class="nd">@ti.func</span>
<span class="k">def</span> <span class="nf">complex_sqr</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">paint</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span> <span class="c1"># 对于所有像素，并行执行</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.2</span><span class="p">])</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">])</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">z</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">20</span> <span class="ow">and</span> <span class="n">iterations</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">:</span>
      <span class="n">z</span> <span class="o">=</span> <span class="n">complex_sqr</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span>
      <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">iterations</span> <span class="o">*</span> <span class="mf">0.02</span>

<span class="n">gui</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="p">(</span><span class="s2">&quot;Fractal&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
  <span class="n">paint</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">0.03</span><span class="p">)</span>
  <span class="n">gui</span><span class="o">.</span><span class="n">set_image</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>
  <span class="n">gui</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>让我们来深入剖析一下这段简单的 Taichi 程序吧。</p>
<div class="section" id="import-taichi-as-ti">
<h3>import taichi as ti<a class="headerlink" href="#import-taichi-as-ti" title="永久链接至标题">¶</a></h3>
<p>Taichi 是一种嵌入在 Python 中的领域特定语言(<a class="reference external" href="https://en.wikipedia.org/wiki/Domain-specific_language">Domain-Specific Language, DSL</a> )。为了使 Taichi 能像 Python 包一样易于使用，基于这个目标我们做了大量的工程工作——使得每个 Python 程序员能够以最低的学习成本编写 Taichi 程序。你甚至可以选择你最喜欢的 Python 包管理系统、Python IDE 以及其他 Python 包和 Taichi 一起结合使用。</p>
</div>
<div class="section" id="portability">
<h3>可移植性<a class="headerlink" href="#portability" title="永久链接至标题">¶</a></h3>
<p>Taichi 既能在 CPU，也能在 GPU 上运行。你只需根据你的硬件平台初始化 Taichi：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在 GPU 上运行，自动选择后端</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">gpu</span><span class="p">)</span>

<span class="c1"># 在 GPU 上运行， 使用 NVIDIA CUDA 后端</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cuda</span><span class="p">)</span>
<span class="c1"># 在 GPU 上运行， 使用 OpenGL 后端</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">opengl</span><span class="p">)</span>
<span class="c1"># 在 GPU 上运行， 使用苹果 Metal 后端（仅对 OS X）有效</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">metal</span><span class="p">)</span>

<span class="c1"># 在 CPU 上运行 (默认)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cpu</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>不同操作系统所支持的后端：</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="16%" />
<col width="16%" />
<col width="22%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">平台</th>
<th class="head">CPU</th>
<th class="head">CUDA</th>
<th class="head">OpenGL</th>
<th class="head">Metal</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Windows</td>
<td>可用</td>
<td>可用</td>
<td>可用</td>
<td>不可用</td>
</tr>
<tr class="row-odd"><td>Linux</td>
<td>可用</td>
<td>可用</td>
<td>可用</td>
<td>不可用</td>
</tr>
<tr class="row-even"><td>Mac OS X</td>
<td>可用</td>
<td>不可用</td>
<td>不可用</td>
<td>可用</td>
</tr>
</tbody>
</table>
<p>（可用: 该系统上有最完整的支持；不可用: 由于平台限制，我们无法实现该后端）</p>
<p class="last">在参数 <code class="docutils literal notranslate"><span class="pre">arch=ti.gpu</span></code> 下，Taichi 将首先尝试在 CUDA 上运行。如果你的设备不支持 CUDA，那么 Taichi 将会转到 Metal 或 OpenGL。如果所在平台不支持 GPU 后端（CUDA、Metal 或 OpenGL），Taichi 将默认在 CPU 运行。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>当在 Windows 平台 或者 ARM 设备（如 NVIDIA Jetson）上使用 CUDA 后端时， Taichi 会默认分配 1 GB 显存用于张量存储。如需重载显存分配，你可以在初始化的时候通过 <code class="docutils literal notranslate"><span class="pre">ti.init(arch=ti.cuda,</span> <span class="pre">device_memory_GB=3.4)</span></code> 来分配 <code class="docutils literal notranslate"><span class="pre">3.4</span></code> GB 显存，或者使用 <code class="docutils literal notranslate"><span class="pre">ti.init(arch=ti.cuda,</span> <span class="pre">device_memory_fraction=0.3)</span></code> 来分配所有可用显存的 <code class="docutils literal notranslate"><span class="pre">30%</span></code>.</p>
<p class="last">在其他平台上， Taichi 将会使用它的自适应内存分配器来动态分配内存。</p>
</div>
</div>
<div class="section" id="sparse-tensors">
<h3>（稀疏）张量<a class="headerlink" href="#sparse-tensors" title="永久链接至标题">¶</a></h3>
<p>Taichi 是一门面向数据的程序设计语言，其中（稠密、稀疏）张量是第一类公民(First-class Citizen)。在 <a class="reference internal" href="index.html#sparse"><span class="std std-ref">Sparse computation (WIP)</span></a> 这一章节，你可以了解到更多关于稀疏张量的详细信息。</p>
<p>在以上代码中，<code class="docutils literal notranslate"><span class="pre">pixels</span> <span class="pre">=</span> <span class="pre">ti.var(dt=ti.f32,</span> <span class="pre">shape=(n</span> <span class="pre">*</span> <span class="pre">2,</span> <span class="pre">n))</span></code> 分配了一个叫做 <code class="docutils literal notranslate"><span class="pre">pixels</span></code> 的二维张量，大小是 <code class="docutils literal notranslate"><span class="pre">(640,</span> <span class="pre">320)</span></code> ，数据类型是 <code class="docutils literal notranslate"><span class="pre">ti.f32</span></code> （即，C语言中的 <code class="docutils literal notranslate"><span class="pre">float</span></code>）.</p>
</div>
<div class="section" id="functions-and-kernels">
<h3>函数与内核<a class="headerlink" href="#functions-and-kernels" title="永久链接至标题">¶</a></h3>
<p>计算发生在 Taichi 的 <strong>内核(kernel)</strong> 中。内核的参数必须显式指定类型。Taichi 内核与函数中所用的语法，看起来和 Python 的很像，然而 Taichi 的前端编译器会将其转换为 <strong>编译型，静态类型，有词法作用域，并行执行且可微分</strong> 的语言。</p>
<p>Taichi 的 <strong>函数</strong> 可以被 Taichi 内核和其他 Taichi 函数调用，你应该使用关键字 <code class="docutils literal notranslate"><span class="pre">ti.func</span></code> 来进行定义。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><strong>Taichi 作用域与 Python 作用域</strong>：任何被 <code class="docutils literal notranslate"><span class="pre">&#64;ti.kernel</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&#64;ti.func</span></code> 修饰的函数体都处于 Taichi 作用域中，这些代码会由 Taichi 编译器编译。而在 Taichi 作用域之外的就都是 Python 作用域了，它们是单纯的 Python 代码。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>Taichi 内核只有在 Python 作用域中才能调用，也就是说，<strong>我们不支持嵌套内核</strong>。同时，虽然不同函数可以嵌套调用，但 <strong>Taichi 暂不支持递归函数</strong> 。</p>
<p class="last">Taichi 函数只有在 Taichi 作用域中才能调用。</p>
</div>
<p>如果用 CUDA 做类比的话， <code class="docutils literal notranslate"><span class="pre">ti.func</span></code> 就像是 <code class="docutils literal notranslate"><span class="pre">__device__</span></code>，<code class="docutils literal notranslate"><span class="pre">ti.kernel</span></code> 就像是 <code class="docutils literal notranslate"><span class="pre">__global__</span></code>。</p>
</div>
<div class="section" id="parallel-for-loops">
<h3>并行执行的for循环<a class="headerlink" href="#parallel-for-loops" title="永久链接至标题">¶</a></h3>
<p>最外层作用域的 for 循环是被 <strong>自动并行执行</strong> 的。Taichi 的 for 循环具有两种形式， <cite>区间 for 循环</cite>，和 <cite>结构 for 循环</cite>。</p>
<p><strong>区间 for 循环</strong> 和普通的 Python for 循环没多大区别，只是 Taichi 最外层的 for 会并行执行而已。区间 for 循环可以嵌套。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">fill</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span> <span class="c1"># 并行执行</span>
    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span>

    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span> <span class="c1"># 在每个并行的线程中顺序执行</span>
      <span class="n">s</span> <span class="o">+=</span> <span class="n">j</span>

    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">fill_3d</span><span class="p">():</span>
  <span class="c1"># 在区间 3 &lt;= i &lt; 8, 1 &lt;= j &lt; 6, 0 &lt;= k &lt; 9 上展开并行</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="mi">9</span><span class="p">):</span>
    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>是最外层 <strong>作用域</strong> 的循环并行执行，而不是最外层的循环。</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span>@ti.kernel
def foo():
    for i in range(10): # 并行 :-)
        …

@ti.kernel
def bar(k: ti.i32):
    if k &gt; 42:
        for i in range(10): # 串行 :-(
            …
</pre></div>
</div>
</div>
<p><strong>结构 for 循环</strong> 在遍历（稀疏）张量元素的时候很有用。例如在上述的代码中，<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i,</span> <span class="pre">j</span> <span class="pre">in</span> <span class="pre">pixels</span></code> 将遍历所有像素点坐标, 即 <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0),</span> <span class="pre">(0,</span> <span class="pre">1),</span> <span class="pre">(0,</span> <span class="pre">2),</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">(0,</span> <span class="pre">319),</span> <span class="pre">(1,</span> <span class="pre">0),</span> <span class="pre">...,</span> <span class="pre">(639,</span> <span class="pre">319)</span></code>。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">结构 for 循环是 Taichi 稀疏计算（<a class="reference internal" href="index.html#sparse"><span class="std std-ref">Sparse computation (WIP)</span></a>）的关键，它只会遍历稀疏张量中的活跃元素。对于稠密张量而言，所有元素都是活跃元素。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>结构 for 循环只能使用在内核的最外层作用域。</p>
<p>是最外层 <strong>作用域</strong> 的循环并行执行，而不是最外层的循环。</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span>@ti.kernel
def foo():
    for i in x:
        …

@ti.kernel
def bar(k: ti.i32):
    # 最外层作用域是 `if` 语句
    if k &gt; 42:
        for i in x: # 语法错误。结构 for 循环 只能用于最外层作用域
            …
</pre></div>
</div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p><strong>并行循环不支持</strong> <code class="docutils literal notranslate"><span class="pre">break</span></code> 语句：</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
      <span class="o">...</span>
      <span class="k">break</span> <span class="c1"># 错误：并行执行的循环不能有 break</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
          <span class="o">...</span>
          <span class="k">break</span> <span class="c1"># 可以</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="interacting-with-python">
<h3>与 Python 交互<a class="headerlink" href="#interacting-with-python" title="永久链接至标题">¶</a></h3>
<p>所有在 Taichi 作用域（<code class="docutils literal notranslate"><span class="pre">ti.func</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ti.kernel</span></code>）之外的部分都只是单纯的 Python 代码。在 Python 作用域中，你可以通过一般的索引语法访问 Taichi 张量元素。例如，要在 Python 中访问渲染图像的某个像素，只需使用以下代码</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pixels</span><span class="p">[</span><span class="mi">42</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="k">print</span><span class="p">(</span><span class="n">pixels</span><span class="p">[</span><span class="mi">42</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span> <span class="c1"># prints 0.7</span>
</pre></div>
</div>
<p>你也可以使用你最喜爱的 Python 包（例如 <code class="docutils literal notranslate"><span class="pre">numpy</span></code>，<code class="docutils literal notranslate"><span class="pre">pytorch</span></code>，<code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>）与 Taichi 一起配合开发。Taichi 为张量格式转换提供了辅助函数，比如 <code class="docutils literal notranslate"><span class="pre">from_numpy</span></code> 和 <code class="docutils literal notranslate"><span class="pre">to_torch</span></code> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">pixels</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">pixels</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>在 <a class="reference internal" href="index.html#external"><span class="std std-ref">Interacting with external arrays</span></a> 这一章节获得更多有关细节。</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-syntax"></span><div class="section" id="syntax">
<h2>语法<a class="headerlink" href="#syntax" title="永久链接至标题">¶</a></h2>
<div class="section" id="kernels">
<h3>内核<a class="headerlink" href="#kernels" title="永久链接至标题">¶</a></h3>
<p>内核参数必须有类型提示。内核最多只能有 8 个参数，例如，</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">print_xy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>一个内核可以有一个 <strong>标量</strong> 返回值。如果内核有一个返回值，那它必须有类型提示。这个返回值会自动转换到所提示的类型。例如，</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">add_xy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>  <span class="c1"># 等价于： ti.cast(x + y, ti.i32)</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">add_xy</span><span class="p">(</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>  <span class="c1"># 3，因为返回值类型是 ti.i32</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>目前，我们只支持返回一个标量。返回 <code class="docutils literal notranslate"><span class="pre">ti.Matrix</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">ti.Vector</span></code> 是不支持的。Python 方式的返回元组也是不支持的。例如：</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">bad_kernel</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>  <span class="c1"># 错误</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">bad_kernel</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>  <span class="c1"># 错误</span>
</pre></div>
</div>
</div>
<p>在 Taichi 内核中，我们也支持 <strong>模板参数（template arguments）</strong> (参见 <a class="reference internal" href="index.html#template-metaprogramming"><span class="std std-ref">Template metaprogramming</span></a>)  和 <strong>外部数组参数（external array arguments）</strong> (参见 <a class="reference internal" href="index.html#external"><span class="std std-ref">Interacting with external arrays</span></a>)</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>当使用可微编程时，对内核数据结构有一些约定。参见 <a class="reference internal" href="index.html#differentiable"><span class="std std-ref">Differentiable programming</span></a> 中的 <strong>内核简化规则（Kernel Simplicity Rule）</strong> 。</p>
<p class="last">请不要在可微编程中使用内核返回值，因为这种返回值并不会被自动微分追踪。取而代之，可以把结果存入全局变量（例如 <code class="docutils literal notranslate"><span class="pre">loss[None]</span></code>）。</p>
</div>
</div>
<div class="section" id="functions">
<h3>函数<a class="headerlink" href="#functions" title="永久链接至标题">¶</a></h3>
<p>使用 <code class="docutils literal notranslate"><span class="pre">&#64;ti.func</span></code> 来装饰您的 Taichi 函数。这些函数只能在 <cite>Taichi</cite> 作用域内调用。不要在 <cite>Python</cite> 作用域内调用它们。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.func</span>
<span class="k">def</span> <span class="nf">laplacian</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">inv_dx2</span> <span class="o">*</span> <span class="p">(</span>
        <span class="o">-</span><span class="mi">4</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span>
        <span class="n">p</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">fdtd</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_grid</span><span class="p">):</span> <span class="c1"># 并行</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_grid</span><span class="p">):</span> <span class="c1"># 在每个并行的线程中分别顺序执行</span>
            <span class="n">laplacian_p</span> <span class="o">=</span> <span class="n">laplacian</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">laplacian_q</span> <span class="o">=</span> <span class="n">laplacian</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">p</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span>
                <span class="n">c</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">laplacian_q</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span>
                           <span class="n">t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">laplacian_p</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>目前不支持具有多个 <code class="docutils literal notranslate"><span class="pre">return</span></code> 语句的函数。请用 <strong>局部变量</strong> 暂存结果，以便最终只有一个 <code class="docutils literal notranslate"><span class="pre">return</span></code> 语句：</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 错误示范 - 两个返回语句</span>
<span class="nd">@ti.func</span>
<span class="k">def</span> <span class="nf">safe_sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ti</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="mf">0.0</span>

<span class="c1"># 正确示范 - 一个返回语句</span>
<span class="nd">@ti.func</span>
<span class="k">def</span> <span class="nf">safe_sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">rst</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">rst</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">rst</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">return</span> <span class="n">rst</span>
</pre></div>
</div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">目前，所有函数都是强制内联的。因此，不能使用递归。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">函数的参数是以值传递的。</p>
</div>
</div>
<div class="section" id="scalar-arithmetics">
<h3>标量算术<a class="headerlink" href="#scalar-arithmetics" title="永久链接至标题">¶</a></h3>
<p>Taichi 支持的标量函数：</p>
<dl class="function">
<dt id="ti.sin">
<code class="descclassname">ti.</code><code class="descname">sin</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.sin" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.cos">
<code class="descclassname">ti.</code><code class="descname">cos</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.cos" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.asin">
<code class="descclassname">ti.</code><code class="descname">asin</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.asin" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.acos">
<code class="descclassname">ti.</code><code class="descname">acos</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.acos" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.atan2">
<code class="descclassname">ti.</code><code class="descname">atan2</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.atan2" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.cast">
<code class="descclassname">ti.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>x</em>, <em>data_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.cast" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.sqrt">
<code class="descclassname">ti.</code><code class="descname">sqrt</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.sqrt" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.floor">
<code class="descclassname">ti.</code><code class="descname">floor</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.floor" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.ceil">
<code class="descclassname">ti.</code><code class="descname">ceil</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.ceil" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.inv">
<code class="descclassname">ti.</code><code class="descname">inv</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.inv" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.tan">
<code class="descclassname">ti.</code><code class="descname">tan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.tan" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.tanh">
<code class="descclassname">ti.</code><code class="descname">tanh</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.tanh" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.exp">
<code class="descclassname">ti.</code><code class="descname">exp</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.exp" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.log">
<code class="descclassname">ti.</code><code class="descname">log</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.log" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.random">
<code class="descclassname">ti.</code><code class="descname">random</code><span class="sig-paren">(</span><em>data_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.random" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#abs" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="int">
<code class="descname">int</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#int" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="float">
<code class="descname">float</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#float" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="max">
<code class="descname">max</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#max" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="min">
<code class="descname">min</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#min" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pow">
<code class="descname">pow</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pow" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>Python 3 中 <code class="docutils literal notranslate"><span class="pre">/</span></code> （浮点数除法）和 <code class="docutils literal notranslate"><span class="pre">//</span></code> （整数除法）是区分开来的。例如，<code class="docutils literal notranslate"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">2.0</span> <span class="pre">=</span> <span class="pre">0.5</span></code>，<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">0.5</span></code>，<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">//</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">0</span></code>，<code class="docutils literal notranslate"><span class="pre">4.2</span> <span class="pre">//</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">2</span></code>。Taichi 也遵循了这个设计：</p>
<blockquote>
<div><ul class="simple">
<li><strong>true divisions</strong> on integral types will first cast their operands to the default float point type.</li>
<li><strong>floor divisions</strong> on float-point types will first cast their operands to the default integer type.</li>
</ul>
</div></blockquote>
<p class="last">为避免这样的隐式转换，你可以手动使用 <code class="docutils literal notranslate"><span class="pre">ti.cast</span></code> 将你的操作数转换为你需要的类型。参见 <a class="reference internal" href="index.html#default-precisions"><span class="std std-ref">默认精度</span></a> 获取数字类型的更多细节。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>当这些标量函数被作用在 <a class="reference internal" href="index.html#matrix"><span class="std std-ref">Matrices</span></a> 或 <a class="reference internal" href="index.html#vector"><span class="std std-ref">向量</span></a> 上时，它们会被逐个作用到所有元素，例如：</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">]])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">]])</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="c1"># is equivalent to</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># is equivalent to</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="c1"># is equivalent to</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

<span class="n">A</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="c1"># is equivalent to</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span>

<span class="n">A</span> <span class="o">+=</span> <span class="n">B</span>
<span class="c1"># is equivalent to</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="debugging">
<h3>调试<a class="headerlink" href="#debugging" title="永久链接至标题">¶</a></h3>
<p>在 Taichi 作用域中使用 <code class="docutils literal notranslate"><span class="pre">print(x)</span></code> 调试你的程序。例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">inside_taichi_scope</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">233</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="c1">#=&gt; hello 233</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;m is&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="c1">#=&gt; m is [[2, 3, 4], [5, 6, 7]]</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;v is&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="c1">#=&gt; v is [3, 4]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>For now, print is only supported on CPU, CUDA and OpenGL backends.</p>
<p>For the CUDA backend, the printed result won’t shows up until <code class="docutils literal notranslate"><span class="pre">ti.sync()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cuda</span><span class="p">)</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">kern</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;inside kernel&#39;</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s1">&#39;before kernel&#39;</span><span class="p">)</span>
<span class="n">kern</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;after kernel&#39;</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">sync</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;after sync&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>obtains:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>before kernel
after kernel
inside kernel
after
</pre></div>
</div>
<p class="last">Also note that host access or program end will also implicitly invoke for <code class="docutils literal notranslate"><span class="pre">ti.sync()</span></code>.</p>
</div>
</div>
</div>
<span id="document-type"></span><div class="section" id="type-system">
<h2>类型系统<a class="headerlink" href="#type-system" title="永久链接至标题">¶</a></h2>
<div class="section" id="supported-types">
<h3>支持的类型<a class="headerlink" href="#supported-types" title="永久链接至标题">¶</a></h3>
<p>目前，Taichi支持的基本类型有</p>
<ul class="simple">
<li>int8 <code class="docutils literal notranslate"><span class="pre">ti.i8</span></code></li>
<li>int16 <code class="docutils literal notranslate"><span class="pre">ti.i16</span></code></li>
<li>int32 <code class="docutils literal notranslate"><span class="pre">ti.i32</span></code></li>
<li>int64 <code class="docutils literal notranslate"><span class="pre">ti.i64</span></code></li>
<li>uint8 <code class="docutils literal notranslate"><span class="pre">ti.u8</span></code></li>
<li>uint16 <code class="docutils literal notranslate"><span class="pre">ti.u16</span></code></li>
<li>uint32 <code class="docutils literal notranslate"><span class="pre">ti.u32</span></code></li>
<li>uint64 <code class="docutils literal notranslate"><span class="pre">ti.u64</span></code></li>
<li>float32 <code class="docutils literal notranslate"><span class="pre">ti.f32</span></code></li>
<li>float64 <code class="docutils literal notranslate"><span class="pre">ti.f64</span></code></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>每种后端支持的类型分别有：</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="30%" />
<col width="30%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">CPU/CUDA</th>
<th class="head">OpenGL</th>
<th class="head">Metal</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>i8</td>
<td>OK</td>
<td>N/A</td>
<td>OK</td>
</tr>
<tr class="row-odd"><td>i16</td>
<td>OK</td>
<td>N/A</td>
<td>OK</td>
</tr>
<tr class="row-even"><td>i32</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr class="row-odd"><td>i64</td>
<td>OK</td>
<td>EXT</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>u8</td>
<td>OK</td>
<td>N/A</td>
<td>OK</td>
</tr>
<tr class="row-odd"><td>u16</td>
<td>OK</td>
<td>N/A</td>
<td>OK</td>
</tr>
<tr class="row-even"><td>u32</td>
<td>OK</td>
<td>N/A</td>
<td>OK</td>
</tr>
<tr class="row-odd"><td>u64</td>
<td>OK</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>f32</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr class="row-odd"><td>f64</td>
<td>OK</td>
<td>OK</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<p class="last">（OK：已支持，EXT：需要扩展支持，N/A：目前不支持）</p>
</div>
<p>布尔类型应该使用 <code class="docutils literal notranslate"><span class="pre">ti.i32</span></code> 来表示。</p>
<p>不同类型的二进制运算像你提供提升的类型，遵循C编程语言，例如。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">+</span> <span class="pre">f32</span> <span class="pre">=</span> <span class="pre">f32</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">f32</span> <span class="pre">+</span> <span class="pre">f64</span> <span class="pre">=</span> <span class="pre">f64</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">+</span> <span class="pre">i64</span> <span class="pre">=</span> <span class="pre">i64</span></code></li>
</ul>
</div>
<div class="section" id="default-precisions">
<span id="id1"></span><h3>默认精度<a class="headerlink" href="#default-precisions" title="永久链接至标题">¶</a></h3>
<p>默认情况下，数字文字具有32位精度。 例如，<code class="docutils literal notranslate"><span class="pre">42</span></code> 的类型为 <code class="docutils literal notranslate"><span class="pre">ti.i32</span></code> ， <code class="docutils literal notranslate"><span class="pre">3.14</span></code> 的类型为 <code class="docutils literal notranslate"><span class="pre">ti.f32</span></code> 。 初始化Taichi时，可以指定默认的整数和浮点精度（ <code class="docutils literal notranslate"><span class="pre">default_ip</span></code> 和 <code class="docutils literal notranslate"><span class="pre">default_f</span></code> ）：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">default_fp</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">default_fp</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f64</span><span class="p">)</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">default_ip</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">default_ip</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i64</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="type-casts">
<h3>类型转换<a class="headerlink" href="#type-casts" title="永久链接至标题">¶</a></h3>
<p>使用 <code class="docutils literal notranslate"><span class="pre">ti.cast</span></code> 来转换标量值。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mf">1.4</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>

<span class="c1"># 等效地，使用 ``int()`` 和 ``float()``</span>
<span class="c1"># 将值转换为默认浮点/整数类型</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<span class="c1"># 矩阵中的逐元素转换</span>
<span class="n">mat</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="n">mat_int</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">mat_int2</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">ti.bit_cast</span></code> 将值比特转换为另一种数据类型。 基础位将保留在此转换中。 新类型的宽度必须与旧类型的宽度相同。 例如，不允许将 <code class="docutils literal notranslate"><span class="pre">i32</span></code> 转换成 <code class="docutils literal notranslate"><span class="pre">f64</span></code>。 请谨慎使用此操作。</p>
</div>
</div>
<span id="document-tensor_matrix"></span><div class="section" id="tensors-and-matrices">
<span id="tensor"></span><h2>张量与矩阵<a class="headerlink" href="#tensors-and-matrices" title="永久链接至标题">¶</a></h2>
<p>在Taichi中，张量是全局变量。张量分为稀疏张量和密集张量。张量的元素可以是标量，也可以是矩阵。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">尽管数学上矩阵被视为2D张量，但在Taichi中， <strong>张量</strong> 和 <strong>矩阵</strong> 是两个完全不同的概念。 矩阵可以用作张量元素，因此你可以使每个元素都是矩阵的张量。</p>
</div>
<div class="section" id="tensors-of-scalars">
<h3>由标量组成的张量<a class="headerlink" href="#tensors-of-scalars" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">每个全局变量都是个N维张量。</p>
<ul class="simple">
<li>全局 <code class="docutils literal notranslate"><span class="pre">标量</span></code> 被视为标量的0-D张量。</li>
</ul>
</li>
<li><p class="first">总是使用索引访问张量</p>
<blockquote>
<div><ul class="simple">
<li>例如，如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是标量3D张量，则 <code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">j,</span> <span class="pre">k]</span></code> 。</li>
<li>即使访问0-D张量 <code class="docutils literal notranslate"><span class="pre">x</span></code> ，也应使用 <code class="docutils literal notranslate"><span class="pre">x[None]</span> <span class="pre">=</span> <span class="pre">0</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">0</span></code> 。 请 <strong>始终</strong> 使用索引访问张量中的条目。</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">张量元素全部会被初始化为0。</p>
</li>
<li><p class="first">稀疏张量的元素最初是全部未激活的。</p>
</li>
<li><p class="first">详情请见 <a class="reference internal" href="index.html#scalar-tensor"><span class="std std-ref">Tensors of scalars</span></a> 。</p>
</li>
</ul>
</div>
<div class="section" id="tensors-of-matrices">
<h3>由矩阵组成的张量<a class="headerlink" href="#tensors-of-matrices" title="永久链接至标题">¶</a></h3>
<p>张量元素也可以是矩阵。</p>
<p>假设你有一个名为 <code class="docutils literal notranslate"><span class="pre">A</span></code> 的 <code class="docutils literal notranslate"><span class="pre">128</span> <span class="pre">x</span> <span class="pre">64</span></code> 张量，每个元素都包含一个 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">2</span></code> 矩阵。 要分配 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">2</span></code> 矩阵的 <code class="docutils literal notranslate"><span class="pre">128</span> <span class="pre">x</span> <span class="pre">64</span></code> 张量，请使用声明 <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">ti.Matrix(3,</span> <span class="pre">2,</span> <span class="pre">dt=ti.f32,</span> <span class="pre">shape=(128,</span> <span class="pre">64))</span></code> 。</p>
<ul class="simple">
<li>如果要获取网格节点 <code class="docutils literal notranslate"><span class="pre">i,</span> <span class="pre">j</span></code> 的矩阵，请使用 <code class="docutils literal notranslate"><span class="pre">mat</span> <span class="pre">=</span> <span class="pre">A[i,</span> <span class="pre">j]</span></code> 。 <code class="docutils literal notranslate"><span class="pre">mat</span></code> 只是一个 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">2</span></code> 矩阵</li>
<li>要获取第1行第2列的矩阵元素，请用： <code class="docutils literal notranslate"><span class="pre">mat[0,</span> <span class="pre">1]</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">A[i,</span> <span class="pre">j][0,</span> <span class="pre">1]</span></code> 。</li>
<li>你可能已经注意到，当你从全局矩阵张量加载矩阵元素时，会有 <strong>两个</strong> 索引运算符 <code class="docutils literal notranslate"><span class="pre">[]</span></code>：第一个用于张量索引，第二个用于矩阵索引。</li>
<li><code class="docutils literal notranslate"><span class="pre">ti.Vector</span></code> 其实是 <code class="docutils literal notranslate"><span class="pre">ti.Matrix</span></code> 的别名。</li>
<li>有关矩阵的更多信息，请参见 <a class="reference internal" href="index.html#matrix"><span class="std std-ref">Matrices</span></a> 。</li>
</ul>
</div>
<div class="section" id="matrix-size">
<h3>矩阵大小<a class="headerlink" href="#matrix-size" title="永久链接至标题">¶</a></h3>
<p>由于性能原因，矩阵运算将被展开，因此我们建议仅使用小型矩阵。 例如，<code class="docutils literal notranslate"><span class="pre">2x1</span></code>， <code class="docutils literal notranslate"><span class="pre">3x3</span></code> ， <code class="docutils literal notranslate"><span class="pre">4x4</span></code> 矩阵还好，但 <code class="docutils literal notranslate"><span class="pre">32x6</span></code> 可能太大了。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">由于展开机制，在大型矩阵（例如 <code class="docutils literal notranslate"><span class="pre">32x128</span></code> ）上进行操作会导致很长的编译时间和较低的性能。</p>
</div>
<p>如果你的矩阵有个维度很大（比如 <code class="docutils literal notranslate"><span class="pre">64</span></code>），最好定义一个大小为 <code class="docutils literal notranslate"><span class="pre">64</span></code> 的张量。比如，声明一个 <code class="docutils literal notranslate"><span class="pre">ti.Matrix(64,</span> <span class="pre">32,</span> <span class="pre">dt=ti.f32,</span> <span class="pre">shape=(3,</span> <span class="pre">2))</span></code> 是不合理的，可以试着用 <code class="docutils literal notranslate"><span class="pre">ti.Matrix(3,</span> <span class="pre">2,</span> <span class="pre">dt=ti.f32,</span> <span class="pre">shape=(64,</span> <span class="pre">32))</span></code> 代替——始终把大的维度放在张量里。</p>
</div>
</div>
<span id="document-atomic"></span><div class="section" id="atomic-operations">
<span id="atomic"></span><h2>原子操作<a class="headerlink" href="#atomic-operations" title="永久链接至标题">¶</a></h2>
<p>在Taichi中，增量赋值（例如，<code class="docutils literal notranslate"><span class="pre">x[i]</span> <span class="pre">+=</span> <span class="pre">1</span></code> ）自动即为 <a class="reference external" href="https://en.wikipedia.org/wiki/Fetch-and-add">原子操作</a>。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>并行修改全局变量时，请确保使用原子操作。 例如，合计 <code class="docutils literal notranslate"><span class="pre">x</span></code> 中的所有元素，</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">sum</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="c1"># 方式 1: 正确</span>
        <span class="n">total</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># 方式 2: 正确</span>
        <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="n">total</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># 方式 3: 非原子操作因而会得到错误结果</span>
        <span class="n">total</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">当将原子操作应用于局部值时，Taichi编译器将尝试将这些运算降级为它们的非原子对应值。</p>
</div>
<p>除了增量赋值(augmented assignment)之外，显式的原子操作（例如 <code class="docutils literal notranslate"><span class="pre">ti.atomic_add</span></code> ）也可以原子地进行读取-修改-写入。 这些操作还会返回第一个参数的 <strong>旧值</strong> 。</p>
<p>以下是所有显式原子操作的列表：</p>
<dl class="function">
<dt id="ti.atomic_add">
<code class="descclassname">ti.</code><code class="descname">atomic_add</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.atomic_add" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.atomic_sub">
<code class="descclassname">ti.</code><code class="descname">atomic_sub</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.atomic_sub" title="永久链接至目标">¶</a></dt>
<dd><p>原子地计算 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 或 <code class="docutils literal notranslate"><span class="pre">x-y</span></code> 并将结果存储在 <code class="docutils literal notranslate"><span class="pre">x</span></code> 中。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">返回:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">x</span></code> 的旧值。</td>
</tr>
</tbody>
</table>
<p>例如，:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="c1"># 现在 x[i] = 7, y[i] = 4, z[i] = 3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ti.atomic_and">
<code class="descclassname">ti.</code><code class="descname">atomic_and</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.atomic_and" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.atomic_or">
<code class="descclassname">ti.</code><code class="descname">atomic_or</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.atomic_or" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.atomic_xor">
<code class="descclassname">ti.</code><code class="descname">atomic_xor</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.atomic_xor" title="永久链接至目标">¶</a></dt>
<dd><p>原子式计算 <code class="docutils literal notranslate"><span class="pre">x＆y</span></code> （按位和）， <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></code> （按位或），或者 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">^</span> <span class="pre">y</span></code> （按位异或），并将结果存储在 <code class="docutils literal notranslate"><span class="pre">x</span></code> 中。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">返回:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">x</span></code> 的旧值。</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>每个后端所支持的原子操作：</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="27%" />
<col width="27%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">CPU/CUDA</th>
<th class="head">OpenGL</th>
<th class="head">Metal</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">i32</span></code></td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">f32</span></code></td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">i64</span></code></td>
<td>OK</td>
<td>EXT</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">f64</span></code></td>
<td>OK</td>
<td>EXT</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<p class="last">（OK：已支持，EXT：需要扩展支持，N/A：目前不支持）</p>
</div>
</div>
<span id="document-external"></span><div class="section" id="interacting-with-external-arrays">
<span id="external"></span><h2>与外部数组进行交互<a class="headerlink" href="#interacting-with-external-arrays" title="永久链接至标题">¶</a></h2>
<p><strong>External arrays</strong> refer to <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code>.</p>
<div class="section" id="conversion-between-taichi-tensors-and-external-arrays">
<h3>Taichi张量与外部数组之间的转换<a class="headerlink" href="#conversion-between-taichi-tensors-and-external-arrays" title="永久链接至标题">¶</a></h3>
<p>使用 <code class="docutils literal notranslate"><span class="pre">to_numpy</span></code>/<code class="docutils literal notranslate"><span class="pre">from_numpy</span></code>/<code class="docutils literal notranslate"><span class="pre">to_torch</span></code>/<code class="docutils literal notranslate"><span class="pre">from_torch</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">7</span>

<span class="c1"># Taichi tensors</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
<span class="n">vec</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
<span class="n">mat</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>

<span class="c1"># Scalar</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">val</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="n">arr</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

<span class="c1"># Vector</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">vec</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">vec</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="n">arr</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">arr</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">keep_dims</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Matrix</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">mat</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="n">arr</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>TODO: add API reference</p>
</div>
<div class="section" id="using-external-arrays-as-taichi-kernel-parameters">
<h3>Using external arrays as Taichi kernel parameters<a class="headerlink" href="#using-external-arrays-as-taichi-kernel-parameters" title="永久链接至标题">¶</a></h3>
<p>外部数组参数的类型提示是 <code class="docutils literal notranslate"><span class="pre">ti.ext_arr()</span></code>。请参阅下面的示例。请注意，结构for循环不支持外部数组。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">7</span>

<span class="n">val</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">test_numpy</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">ext_arr</span><span class="p">()):</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span>

<span class="n">test_numpy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-scalar_tensor"></span><div class="section" id="tensors-of-scalars">
<span id="scalar-tensor"></span><h2>标量组成的张量<a class="headerlink" href="#tensors-of-scalars" title="永久链接至标题">¶</a></h2>
<div class="section" id="declaration">
<h3>定义<a class="headerlink" href="#declaration" title="永久链接至标题">¶</a></h3>
<dl class="function">
<dt id="ti.var">
<code class="descclassname">ti.</code><code class="descname">var</code><span class="sig-paren">(</span><em>dt</em>, <em>shape = None</em>, <em>offset = None</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.var" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>dt</strong> – （数据类型）张量元素的数据类型</li>
<li><strong>shape</strong> – （可选，标量或元组）张量的形状</li>
<li><strong>offset</strong> – （可选，标量或元组）请参见 <a class="reference internal" href="index.html#offset"><span class="std std-ref">Coordinate offsets</span></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>例如，这将创建一个具有四个 <code class="docutils literal notranslate"><span class="pre">int32</span></code> 作为元素的 <em>稠密(dense)</em> 张量：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>这将创建一个元素为 <code class="docutils literal notranslate"><span class="pre">float32</span></code> 类型的4x3 <em>稠密</em> 张量：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>如果 shape 是 <code class="docutils literal notranslate"><span class="pre">()</span></code> （空元组），则创建一个0-D张量（标量）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
</pre></div>
</div>
<p>随后通过传递 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为索引来访问它：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>如果形状参数 <strong>未提供</strong> 或指定为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则其后用户必须在手动放置 (place) 它：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ij</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># 等价于: x = ti.var(ti.f32, shape=(4, 3))</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">通过不指定参数 <code class="docutils literal notranslate"><span class="pre">shape</span></code> 的写法，你可以将张量 <em>放置</em> 为默认的 <em>稠密数据布局</em> 之外的其他布局中，有关更多详细信息，请参见： <a class="reference internal" href="index.html#layout"><span class="std std-ref">Advanced dense layouts</span></a> 。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>在任何内核调用或变量访问之前，所有变量都必须被创建和放置完毕。例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">x</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 错误：x没有放置!</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="n">x</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">func</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
<span class="c1"># 错误：内核调用后不能再创建新的变量!</span>
</pre></div>
</div>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
<span class="n">x</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
<span class="c1"># 错误：任一变量访问过后不能再创建新的变量!</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="accessing-components">
<h3>访问分量<a class="headerlink" href="#accessing-components" title="永久链接至标题">¶</a></h3>
<p>您可以通过一个或多个索引来访问 Taichi 张量的元素。</p>
<dl class="attribute">
<dt>
<code class="descname">a[p, q, ...]</code></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – （张量）标量张量</li>
<li><strong>p</strong> – 第一个张量维度的（标量）索引</li>
<li><strong>q</strong> – 第二个张量维度的（标量）索引</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">（标量） <code class="docutils literal notranslate"><span class="pre">[p,</span> <span class="pre">q,</span> <span class="pre">...]</span></code> 处的元素</p>
</td>
</tr>
</tbody>
</table>
<p>这将提取张量 <code class="docutils literal notranslate"><span class="pre">a</span></code> 在索引为 <code class="docutils literal notranslate"><span class="pre">[3,</span> <span class="pre">4]</span></code> 处的元素值：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>这会将一维张量 <code class="docutils literal notranslate"><span class="pre">b</span></code> 在索引 <code class="docutils literal notranslate"><span class="pre">2</span></code> 处的元素值设置为 <code class="docutils literal notranslate"><span class="pre">5</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">在 Python 中， x[(exp1, exp2, …, expN)] 等效于 x[(exp1, exp2, …, expN)] ; 后者只是前者的语法糖。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果 <code class="docutils literal notranslate"><span class="pre">a</span></code> 是由 <code class="docutils literal notranslate"><span class="pre">Vector</span></code> / <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> 构成的张量，则返回的值也可以是 Vector / Matrix，有关更多详细信息，请参见： <a class="reference internal" href="index.html#vector"><span class="std std-ref">向量</span></a>。</p>
</div>
</dd></dl>

</div>
<div class="section" id="meta-data">
<h3>元数据<a class="headerlink" href="#meta-data" title="永久链接至标题">¶</a></h3>
<dl class="function">
<dt id="a.dim">
<code class="descclassname">a.</code><code class="descname">dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#a.dim" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>a</strong> – （张量）张量</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">（标量） <code class="docutils literal notranslate"><span class="pre">a</span></code> 的长度</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">x</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>  <span class="c1"># 2</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">y</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>  <span class="c1"># 1</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="p">())</span>
<span class="n">z</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>  <span class="c1"># 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="a.shape">
<code class="descclassname">a.</code><code class="descname">shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#a.shape" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>a</strong> – （张量）张量</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">（元组）张量 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的形状</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>  <span class="c1"># (6, 5)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>  <span class="c1"># (6,)</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="p">())</span>
<span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>  <span class="c1"># ()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="a.data_type">
<code class="descclassname">a.</code><code class="descname">data_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#a.data_type" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>a</strong> – （张量）张量</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">（数据类型） <code class="docutils literal notranslate"><span class="pre">a</span></code> 的数据类型</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">x</span><span class="o">.</span><span class="n">data_type</span><span class="p">()</span>  <span class="c1"># ti.i32</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="a.parent">
<code class="descclassname">a.</code><code class="descname">parent</code><span class="sig-paren">(</span><em>n = 1</em><span class="sig-paren">)</span><a class="headerlink" href="#a.parent" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – （张量）张量</li>
<li><strong>n</strong> – （可选，标量）父级步数，即父级节点为 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">1</span></code>，祖父级节点为 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2</span></code>，等等。</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">（结构节点） <code class="docutils literal notranslate"><span class="pre">a</span></code> 所属结构节点的父类节点</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span>
<span class="n">blk1</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ij</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">blk2</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ij</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">blk1</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">blk2</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>   <span class="c1"># blk1</span>
<span class="n">y</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>   <span class="c1"># blk2</span>
<span class="n">y</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># blk1</span>
</pre></div>
</div>
<p>有关更多详细信息，请参见 <a class="reference internal" href="index.html#snode"><span class="std std-ref">Structural nodes (SNodes)</span></a> 。</p>
</dd></dl>

</div>
</div>
<span id="document-vector"></span><div class="section" id="vectors">
<span id="vector"></span><h2>向量<a class="headerlink" href="#vectors" title="永久链接至标题">¶</a></h2>
<p>在Taichi中，向量的表述有两种形式：</p>
<blockquote>
<div><ul class="simple">
<li>作为临时局部变量，一个 <code class="docutils literal notranslate"><span class="pre">n</span></code> 分量的向量由标量 <code class="docutils literal notranslate"><span class="pre">n</span></code> 组成。</li>
<li>作为全局张量(global tensor)的构成元素。比如，由向量 <code class="docutils literal notranslate"><span class="pre">n</span></code> 组成的N-维数组构成了的一个全局张量。</li>
</ul>
</div></blockquote>
<p>In fact, <code class="docutils literal notranslate"><span class="pre">Vector</span></code> is simply an alias of <code class="docutils literal notranslate"><span class="pre">Matrix</span></code>, just with <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">1</span></code>. See <a class="reference internal" href="index.html#matrix"><span class="std std-ref">Matrices</span></a> and <a class="reference internal" href="index.html#tensor"><span class="std std-ref">张量与矩阵</span></a> for more details.</p>
<div class="section" id="declaration">
<h3>声明向量<a class="headerlink" href="#declaration" title="永久链接至标题">¶</a></h3>
<div class="section" id="as-global-tensors-of-vectors">
<h4>全局张量中的向量<a class="headerlink" href="#as-global-tensors-of-vectors" title="永久链接至标题">¶</a></h4>
<dl class="function">
<dt id="ti.Vector">
<code class="descclassname">ti.</code><code class="descname">Vector</code><span class="sig-paren">(</span><em>n</em>, <em>dt</em>, <em>shape = None</em>, <em>offset = None</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.Vector" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – (标量) 向量中分量数目</li>
<li><strong>dt</strong> – (数据类型) 向量中分量的数据类型</li>
<li><strong>shape</strong> – (optional, scalar or tuple) shape the tensor of vectors, see <a class="reference internal" href="index.html#tensor"><span class="std std-ref">张量与矩阵</span></a></li>
<li><strong>offset</strong> – (optional, scalar or tuple) see <a class="reference internal" href="index.html#offset"><span class="std std-ref">Coordinate offsets</span></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>例如, 这里我们创建了一个5x4的张量，张量中的元素都是3维的向量:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Python-scope</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">在Python-scope中, <code class="docutils literal notranslate"><span class="pre">ti.var</span></code> 声明 <a class="reference internal" href="index.html#scalar-tensor"><span class="std std-ref">Tensors of scalars</span></a>, 而 <code class="docutils literal notranslate"><span class="pre">ti.Vector</span></code> 声明了由向量构成的张量。</p>
</div>
</div>
<div class="section" id="as-a-temporary-local-variable">
<h4>临时局部变量向量<a class="headerlink" href="#as-a-temporary-local-variable" title="永久链接至标题">¶</a></h4>
<dl class="function">
<dt>
<code class="descclassname">ti.</code><code class="descname">Vector</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em>, <em>y</em>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – (标量)向量的第一个分量</li>
<li><strong>y</strong> – (标量)向量的第二个分量</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>例如, 我们可以使用 (2, 3, 4)创建一个三维向量:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Taichi-scope</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="accessing-components">
<h3>访问向量分量<a class="headerlink" href="#accessing-components" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>全局张量中的向量<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<dl class="attribute">
<dt>
<code class="descname">a[p, q, ...][i]</code></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – (向量)</li>
<li><strong>p</strong> – (标量) 张量的行索引</li>
<li><strong>q</strong> – (标量) 张量的列索引</li>
<li><strong>i</strong> – (标量) 向量内分量的索引</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>这里提取出了向量 <code class="docutils literal notranslate"><span class="pre">a[6,</span> <span class="pre">3]</span></code> 的第一个分量:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># or</span>
<span class="n">vec</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p><strong>Always</strong> use two pairs of square brackets to access scalar elements from tensors of vectors.</p>
<blockquote>
<div><ul class="simple">
<li>第一组方括号负责定位张量中的向量;</li>
<li>第二组方括号负责定位向量中的标量。</li>
</ul>
</div></blockquote>
<p class="last">特别的，对0维张量第一组方括号应该使用 <code class="docutils literal notranslate"><span class="pre">[None]</span></code> 。</p>
</div>
</div>
<div class="section" id="id2">
<h4>临时局部变量向量<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<dl class="attribute">
<dt>
<code class="descname">a[i]</code></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – (向量)</li>
<li><strong>i</strong> – 指定访问下标</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>例如，这里我们提取出了向量 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的第一个分量:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>同理，将 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的第二个分量设置为 4:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>TODO: add descriptions about <code class="docutils literal notranslate"><span class="pre">a(i,</span> <span class="pre">j)</span></code></p>
</dd></dl>

</div>
</div>
<div class="section" id="methods">
<h3>相关方法<a class="headerlink" href="#methods" title="永久链接至标题">¶</a></h3>
<dl class="function">
<dt id="a.norm">
<code class="descclassname">a.</code><code class="descname">norm</code><span class="sig-paren">(</span><em>eps = 0</em><span class="sig-paren">)</span><a class="headerlink" href="#a.norm" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – (向量)向量</li>
<li><strong>eps</strong> – (可选标量) sqrt的安全保护值，通常为0. 详见下面注解。</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(标量) 向量的大小、长度、范数</p>
</td>
</tr>
</tbody>
</table>
<p>例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">a</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="c1"># sqrt(3*3 + 4*4 + 0) = 5</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">a.norm(eps)</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">ti.sqrt(a.dot(a)</span> <span class="pre">+</span> <span class="pre">eps)</span></code></p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">可以通过设置 <code class="docutils literal notranslate"><span class="pre">eps</span> <span class="pre">=</span> <span class="pre">1e-5</span></code> ,对可微分编程中零向量上的梯度值计算进行防护。</p>
</div>
<dl class="function">
<dt id="a.dot">
<code class="descclassname">a.</code><code class="descname">dot</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#a.dot" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – (向量)向量</li>
<li><strong>b</strong> – (向量)向量</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(标量) <code class="docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b</span></code> 之间点乘（内积）的结果</p>
</td>
</tr>
</tbody>
</table>
<p>例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># 1*2 + 3*4 = 14</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="a.cross">
<code class="descclassname">a.</code><code class="descname">cross</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#a.cross" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – (Vector, 2 or 3 components)</li>
<li><strong>b</strong> – (Vector of the same size as a)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(scalar (for 2D inputs), or 3D Vector (for 3D inputs)) the cross product of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</td>
</tr>
</tbody>
</table>
<p>We use a right-handed coordinate system. E.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="c1"># c = [2*6 - 5*3, 4*3 - 1*6, 1*5 - 4*2] = [-3, 6, -3]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="c1"># r = 1*5 - 4*2 = -3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="a.outer_product">
<code class="descclassname">a.</code><code class="descname">outer_product</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#a.outer_product" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – (向量)向量</li>
<li><strong>b</strong> – (向量)向量</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(矩阵) <code class="docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b</span></code> 之间张量积的结果</p>
</td>
</tr>
</tbody>
</table>
<p>例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">outer_product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># NOTE: c[i, j] = a[i] * b[j]</span>
<span class="c1"># c = [[1*4, 1*5, 1*6], [2*4, 2*5, 2*6]]</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">This have no common with <code class="docutils literal notranslate"><span class="pre">ti.cross</span></code>. <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> do not have to be 3 or 2 component vectors.</p>
</div>
<dl class="function">
<dt id="a.cast">
<code class="descclassname">a.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>dt</em><span class="sig-paren">)</span><a class="headerlink" href="#a.cast" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – (向量)向量</li>
<li><strong>dt</strong> – (DataType)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(向量) 将向量 <code class="docutils literal notranslate"><span class="pre">a</span></code> 中分量的数据类型转化为类型 <code class="docutils literal notranslate"><span class="pre">dt</span></code></p>
</td>
</tr>
</tbody>
</table>
<p>例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Taichi-scope</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">1.6</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">])</span>
<span class="n">a</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span> <span class="c1"># [2, 3]</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">向量是只有一列的特殊矩阵。实际上，<code class="docutils literal notranslate"><span class="pre">ti.Vector</span></code> 只是 <code class="docutils literal notranslate"><span class="pre">ti.Matrix</span></code> 的别名。</p>
</div>
<p>TODO: add element wise operations docs</p>
</div>
</div>
<span id="document-matrix"></span><div class="section" id="matrices">
<span id="matrix"></span><h2>矩阵<a class="headerlink" href="#matrices" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ti.Matrix</span></code> 只适用于小矩阵（如3x3）。如果要使用 <cite>64x64</cite> 的矩阵，你可以用标量构成的二维张量。</li>
<li><code class="docutils literal notranslate"><span class="pre">ti.Vector</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ti.Matrix</span></code> 相同，只不过它只有一列。</li>
<li>注意区分逐元素的乘法 <code class="docutils literal notranslate"><span class="pre">*</span></code> 和矩阵乘法 <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 。</li>
<li><code class="docutils literal notranslate"><span class="pre">ti.Vector(n,</span> <span class="pre">dt=ti.f32)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ti.Matrix(n,</span> <span class="pre">m,</span> <span class="pre">dt=ti.f32)</span></code> 用来创建向量/矩阵构成的张量。</li>
<li><code class="docutils literal notranslate"><span class="pre">A.transpose()</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">A.inverse()</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">A.trace()</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">A.determinant()</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">A.cast(type)</span></code> or simply <code class="docutils literal notranslate"><span class="pre">int(A)</span></code> and <code class="docutils literal notranslate"><span class="pre">float(A)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">R,</span> <span class="pre">S</span> <span class="pre">=</span> <span class="pre">ti.polar_decompose(A,</span> <span class="pre">ti.f32)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">U,</span> <span class="pre">sigma,</span> <span class="pre">V</span> <span class="pre">=</span> <span class="pre">ti.svd(A,</span> <span class="pre">ti.f32)</span></code>  （其中 <code class="docutils literal notranslate"><span class="pre">sigma</span></code> 是一个 <code class="docutils literal notranslate"><span class="pre">3x3</span></code> 矩阵）</li>
<li><code class="docutils literal notranslate"><span class="pre">any(A)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">all(A)</span></code></li>
<li>Currently, only <code class="docutils literal notranslate"><span class="pre">+,</span> <span class="pre">-,</span> <span class="pre">&#64;</span></code> Matrix operations have experimental support in Python-scope. An exception will be raised if you try to apply other operations in Python-scope, use them in Taichi-scope (<cite>&#64;ti.kernel</cite>) instead.</li>
</ul>
<p>TODO: doc here better like Vector. WIP</p>
<p>Taichi中的矩阵有两种形式：</p>
<blockquote>
<div><ul class="simple">
<li>作为临时本地变量。一个由 <code class="docutils literal notranslate"><span class="pre">n*m</span></code> 个标量构成的 <code class="docutils literal notranslate"><span class="pre">n×m</span></code> 阶矩阵。</li>
<li>作为全局张量的一个成员。在这种情况下， 张量是一个由 <code class="docutils literal notranslate"><span class="pre">n×m</span></code> 阶矩阵构成的N-维的数组。</li>
</ul>
</div></blockquote>
<div class="section" id="declaration">
<h3>定义<a class="headerlink" href="#declaration" title="永久链接至标题">¶</a></h3>
<div class="section" id="as-global-tensors-of-matrices">
<h4>作为全局张量的矩阵<a class="headerlink" href="#as-global-tensors-of-matrices" title="永久链接至标题">¶</a></h4>
<dl class="function">
<dt id="ti.Matrix">
<code class="descclassname">ti.</code><code class="descname">Matrix</code><span class="sig-paren">(</span><em>n</em>, <em>m</em>, <em>dt</em>, <em>shape = None</em>, <em>offset = None</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.Matrix" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – （标量）矩阵的行数</li>
<li><strong>m</strong> – （标量）矩阵的列数</li>
<li><strong>dt</strong> – （数据类型）元素的数据类型</li>
<li><strong>shape</strong> – (optional, scalar or tuple) shape the tensor of vectors, see <a class="reference internal" href="index.html#tensor"><span class="std std-ref">张量与矩阵</span></a></li>
<li><strong>offset</strong> – (optional, scalar or tuple) see <a class="reference internal" href="index.html#offset"><span class="std std-ref">Coordinate offsets</span></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>例如， 以下创建了一个由 3x3 矩阵构成的 5x4 的张量：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Python-scope</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">在 Python-scope 中， <code class="docutils literal notranslate"><span class="pre">ti.var</span></code> 声明了 <a class="reference internal" href="index.html#scalar-tensor"><span class="std std-ref">Tensors of scalars</span></a> , <code class="docutils literal notranslate"><span class="pre">ti.Matrix</span></code> 声明了矩阵形式的张量。</p>
</div>
</div>
<div class="section" id="as-a-temporary-local-variable">
<h4>作为一个临时的本地变量<a class="headerlink" href="#as-a-temporary-local-variable" title="永久链接至标题">¶</a></h4>
<dl class="function">
<dt>
<code class="descclassname">ti.</code><code class="descname">Matrix</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em>, <em>y</em>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – （标量）向量的第一个元素</li>
<li><strong>y</strong> – （标量）向量的第二个元素</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>比如，创建一个元素为 (2, 3, 4) 的 3x1 阶矩阵:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Taichi-scope</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">等价于 ti.Vector([x, y, …])</p>
</div>
<dl class="function">
<dt>
<code class="descclassname">ti.</code><code class="descname">Matrix</code><span class="sig-paren">(</span><span class="optional">[</span><span class="optional">[</span><em>x</em>, <em>y</em>, <em>...</em><span class="optional">]</span><span class="optional">[</span>, <em>z</em>, <em>w</em>, <em>...</em><span class="optional">]</span>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – （标量）第一行第一个元素</li>
<li><strong>y</strong> – （标量）第一行第二个元素</li>
<li><strong>z</strong> – （标量）第二行第一个元素</li>
<li><strong>w</strong> – （标量）第二行第二个元素</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>For example, this creates a 2x3 matrix with components (2, 3, 4) in the first row and (5, 6, 7) in the second row:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Taichi-scope</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ti.Matrix.rows">
<code class="descclassname">ti.Matrix.</code><code class="descname">rows</code><span class="sig-paren">(</span><span class="optional">[</span><em>v0</em>, <em>v1</em>, <em>v2</em>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ti.Matrix.rows" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.Matrix.cols">
<code class="descclassname">ti.Matrix.</code><code class="descname">cols</code><span class="sig-paren">(</span><span class="optional">[</span><em>v0</em>, <em>v1</em>, <em>v2</em>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ti.Matrix.cols" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>v0</strong> – （向量）组成第一行（列）元素的向量</li>
<li><strong>v1</strong> – （向量）组成第二行（列）元素的向量</li>
<li><strong>v2</strong> – （向量）组成第三行（列）元素的向量</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>比如，以下代码通过将向量连接作为一个3x3矩阵的每一行（列）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Taichi-scope</span>
<span class="n">v0</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">])</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">])</span>

<span class="c1"># to specify data in rows</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">([</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">])</span>

<span class="c1"># to specify data in columns instead</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">cols</span><span class="p">([</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">])</span>

<span class="c1"># lists can be used instead of vectors</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="accessing-components">
<h3>元素访问<a class="headerlink" href="#accessing-components" title="永久链接至标题">¶</a></h3>
<div class="section" id="as-global-tensors-of-vectors">
<h4>作为全局的由向量构成的张量<a class="headerlink" href="#as-global-tensors-of-vectors" title="永久链接至标题">¶</a></h4>
<dl class="attribute">
<dt>
<code class="descname">a[p, q, ...][i, j]</code></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – （矩阵构成的张量）张量名</li>
<li><strong>p</strong> – （标量）张量的第一维的索引</li>
<li><strong>q</strong> – （标量）张量的第二维的索引</li>
<li><strong>i</strong> – （标量）矩阵的行索引</li>
<li><strong>j</strong> – （标量）矩阵的列索引</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>以下代码用以访问矩阵 <code class="docutils literal notranslate"><span class="pre">a[6,3]</span></code> 的第一个元素：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="c1"># or</span>
<span class="n">mat</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>访问矩阵形式张量中的标量元素时， <strong>必须</strong> 使用两对方括号。</p>
<blockquote>
<div><ul class="simple">
<li>第一对方括号中的下标找到张量中的矩阵;</li>
<li>第二对方括号中的下标找到矩阵中的标量元素。</li>
</ul>
</div></blockquote>
<p class="last">对于0维的矩阵形式的张量，第一对方括号中的下标应该为 <code class="docutils literal notranslate"><span class="pre">[None]</span></code> 。</p>
</div>
</div>
<div class="section" id="id1">
<h4>作为一个临时的本地变量<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<dl class="attribute">
<dt>
<code class="descname">a[i, j]</code></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – （矩阵）该矩阵本身</li>
<li><strong>i</strong> – （标量）矩阵的行索引</li>
<li><strong>j</strong> – （标量）矩阵的列索引</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>比如，访问矩阵 <code class="docutils literal notranslate"><span class="pre">a</span></code> 第0行第1列的元素：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>将 <code class="docutils literal notranslate"><span class="pre">a</span></code> 第1行第3列的元素设置为4：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="methods">
<h3>Methods<a class="headerlink" href="#methods" title="永久链接至标题">¶</a></h3>
<p>TODO: WIP</p>
<p>TODO: add element wise operations docs</p>
</div>
</div>
<span id="document-snode"></span><div class="section" id="structural-nodes-snodes">
<span id="snode"></span><h2>结构节点 (SNodes)<a class="headerlink" href="#structural-nodes-snodes" title="永久链接至标题">¶</a></h2>
<p>在编写计算部分的代码之后，用户需要设定内部层次数据结构。包括微观和宏观两部分，宏观上设定层级数据结构组件之间的嵌套关系以及表示稀疏性的方式；微观上，描述数据如何分组(例如，SOA 或 AOS)。Taichi 提供了 <em>结构节点 (SNodes)</em> 以满足不同层级数据结构构建时的需求。其结构和语义具体如下所示：</p>
<ul class="simple">
<li>稠密集合(dense)：固定长度的连续数组。</li>
<li>位掩码集合(bitmasked)：类似于稠密集合，但实现了通过掩码保持数据的稀疏信息。比如为稠密集合的元素分配掩码来记录稀疏信息。</li>
<li>指针集合(pointer)：存储指针而不是整个结构，以节省内存和保持稀疏性。</li>
<li>动态集合(dynamic)：可变长度数组，具有预定义的最大长度。它扮演着 C++ 中的 <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> 或者是 Python 中的 <code class="docutils literal notranslate"><span class="pre">list</span></code> 这样的角色，可以用来维护包含在一个块(block)中的对象（例如粒子）。</li>
</ul>
<p>你可以在 <a class="reference internal" href="index.html#layout"><span class="std std-ref">Advanced dense layouts</span></a> 章节中了解更多详细信息。 <code class="docutils literal notranslate"><span class="pre">ti.root</span></code> 是层级数据结构的根结点.</p>
<dl class="function">
<dt id="snode.place">
<code class="descclassname">snode.</code><code class="descname">place</code><span class="sig-paren">(</span><em>x</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#snode.place" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>snode</strong> – (结构节点) 放置(place)操作的目标</li>
<li><strong>x</strong> – (张量) 要放置的张量对象</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(结构节点) <code class="docutils literal notranslate"><span class="pre">snode</span></code> 对象</p>
</td>
</tr>
</tbody>
</table>
<p>以下示例代码放置了 <code class="docutils literal notranslate"><span class="pre">x</span></code> 和 <code class="docutils literal notranslate"><span class="pre">y</span></code> 两个零维张量:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="tensor.shape">
<code class="descclassname">tensor.</code><code class="descname">shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensor.shape" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>tensor</strong> – （张量）</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">(整数元组) 张量的形状</td>
</tr>
</tbody>
</table>
<p>例如，</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ijk</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="c1"># returns (3, 5, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="snode.get_shape">
<code class="descclassname">snode.</code><code class="descname">get_shape</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#snode.get_shape" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>snode</strong> – （结构节点）</li>
<li><strong>index</strong> – 指定轴（0 表示 <code class="docutils literal notranslate"><span class="pre">i</span></code> ，1 表示 <code class="docutils literal notranslate"><span class="pre">j</span></code> ）</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(scalar) the size of tensor along that axis</p>
</td>
</tr>
</tbody>
</table>
<p>相当于 <code class="docutils literal notranslate"><span class="pre">tensor.shape()[i]</span></code> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ijk</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span><span class="o">.</span><span class="n">snode</span><span class="p">()</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 3</span>
<span class="n">x</span><span class="o">.</span><span class="n">snode</span><span class="p">()</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 5</span>
<span class="n">x</span><span class="o">.</span><span class="n">snode</span><span class="p">()</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># 4</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="tensor.dim">
<code class="descclassname">tensor.</code><code class="descname">dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensor.dim" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>tensor</strong> – （张量）</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">（标量）张量的维度</td>
</tr>
</tbody>
</table>
<p>相当于 <code class="docutils literal notranslate"><span class="pre">len(tensor.shape())</span></code> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ijk</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>  <span class="c1"># 3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="snode.parent">
<code class="descclassname">snode.</code><code class="descname">parent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snode.parent" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>snode</strong> – （结构节点）</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">（结构节点） <code class="docutils literal notranslate"><span class="pre">snode</span></code> 的父节点</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">blk1</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">blk2</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">blk3</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">.</span><span class="n">bitmasked</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">blk1</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>  <span class="c1"># ti.root</span>
<span class="n">blk2</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>  <span class="c1"># blk1</span>
<span class="n">blk3</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>  <span class="c1"># blk2</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="node-types">
<h3>不同类型的节点<a class="headerlink" href="#node-types" title="永久链接至标题">¶</a></h3>
<dl class="function">
<dt id="snode.dense">
<code class="descclassname">snode.</code><code class="descname">dense</code><span class="sig-paren">(</span><em>indices</em>, <em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#snode.dense" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>snode</strong> – （结构节点） 父节点，返回的子节点就是从该节点派生</li>
<li><strong>indices</strong> – （索引）用于子节点上的索引</li>
<li><strong>shape</strong> – （标量或元组）指定向量张量(tensor of vector)的形状</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">（结构节点）派生出来的子节点</p>
</td>
</tr>
</tbody>
</table>
<p>以下示例代码放置了尺寸为 <code class="docutils literal notranslate"><span class="pre">3</span></code> 的一维张量：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>以下示例代码放置了尺寸为 <code class="docutils literal notranslate"><span class="pre">(3,4)</span></code> 的二维张量：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ij</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>如果给定的 <code class="docutils literal notranslate"><span class="pre">shape</span></code> 是一个标量，却又对应了多个索引，那么 <code class="docutils literal notranslate"><span class="pre">shape</span></code> 将自动扩充直至和索引数量相等。例如,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">snode</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ijk</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>相当于</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">snode</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ijk</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="function">
<dt id="snode.dynamic">
<code class="descclassname">snode.</code><code class="descname">dynamic</code><span class="sig-paren">(</span><em>index</em>, <em>size</em>, <em>chunk_size = None</em><span class="sig-paren">)</span><a class="headerlink" href="#snode.dynamic" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>snode</strong> – （结构节点） 父节点，返回的子节点就是从该节点派生</li>
<li><strong>index</strong> – （索引） 动态集合节点(dynamic node)的索引</li>
<li><strong>size</strong> – （标量）描述该动态集合节点的最大尺寸</li>
<li><strong>chunk_size</strong> – （可选标量）描述动态内存分配时块(chunk)中存储的元素数目</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">（结构节点）派生出来的子节点</p>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">动态集合</span></code> 节点就像 C++ 中的 <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> 或者是 Python 中的 <code class="docutils literal notranslate"><span class="pre">list</span></code> 。Taichi 具有的动态内存分配系统可以实现自由的分配内存。</p>
<p>以下示例代码放置了最大尺寸为 <code class="docutils literal notranslate"><span class="pre">16</span></code> 的一维动态张量：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dynamic</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="snode.bitmasked">
<code class="descclassname">snode.</code><code class="descname">bitmasked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snode.bitmasked" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="snode.pointer">
<code class="descclassname">snode.</code><code class="descname">pointer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snode.pointer" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="snode.hash">
<code class="descclassname">snode.</code><code class="descname">hash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snode.hash" title="永久链接至目标">¶</a></dt>
<dd><p>TODO: add descriptions here</p>
</dd></dl>

</div>
<div class="section" id="working-with-dynamic-snodes">
<h3>动态集合节点的使用<a class="headerlink" href="#working-with-dynamic-snodes" title="永久链接至标题">¶</a></h3>
<dl class="function">
<dt id="ti.length">
<code class="descclassname">ti.</code><code class="descname">length</code><span class="sig-paren">(</span><em>snode</em>, <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.length" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>snode</strong> – （动态集合节点）</li>
<li><strong>indices</strong> – (标量或元组中标量)  <code class="docutils literal notranslate"><span class="pre">动态集合</span></code> 节点的索引</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">（标量）当前动态集合节点的尺寸</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ti.append">
<code class="descclassname">ti.</code><code class="descname">append</code><span class="sig-paren">(</span><em>snode</em>, <em>indices</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.append" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>snode</strong> – （动态集合节点）</li>
<li><strong>indices</strong> – (标量或元组中标量)  <code class="docutils literal notranslate"><span class="pre">动态集合</span></code> 节点的索引</li>
<li><strong>val</strong> – （取决于结构节点的数据类型）想要储存的值</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(<code class="docutils literal notranslate"><span class="pre">int32</span></code>) 附加操作之前动态节点的尺寸</p>
</td>
</tr>
</tbody>
</table>
<p>使用上述函数，就能实现通过 <code class="docutils literal notranslate"><span class="pre">索引(indices)</span></code> 将 <code class="docutils literal notranslate"><span class="pre">常量(val)</span></code> 插入到 <code class="docutils literal notranslate"><span class="pre">动态集合</span></code> 节点中。</p>
</dd></dl>

</div>
<div class="section" id="taichi-tensors-like-powers-of-two">
<h3>Taichi 的张量尺寸<a class="headerlink" href="#taichi-tensors-like-powers-of-two" title="永久链接至标题">¶</a></h3>
<p>对于张量，非整二次幂的那些维度会被扩充为整二次幂，因而会占据更多虚拟地址空间。例如，一个 <code class="docutils literal notranslate"><span class="pre">(18,</span> <span class="pre">65)</span></code> 的稠密张量在实际存储时相当于一个 <code class="docutils literal notranslate"><span class="pre">(32,</span> <span class="pre">128)</span></code> 大小的张量。</p>
</div>
<div class="section" id="indices">
<h3>索引<a class="headerlink" href="#indices" title="永久链接至标题">¶</a></h3>
<dl class="function">
<dt id="ti.i">
<code class="descclassname">ti.</code><code class="descname">i</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ti.i" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.j">
<code class="descclassname">ti.</code><code class="descname">j</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ti.j" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.k">
<code class="descclassname">ti.</code><code class="descname">k</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ti.k" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.ij">
<code class="descclassname">ti.</code><code class="descname">ij</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ti.ij" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.ijk">
<code class="descclassname">ti.</code><code class="descname">ijk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ti.ijk" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.ijkl">
<code class="descclassname">ti.</code><code class="descname">ijkl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ti.ijkl" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ti.indices">
<code class="descclassname">ti.</code><code class="descname">indices</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.indices" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>(TODO)</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-meta"></span><div class="section" id="metaprogramming">
<span id="meta"></span><h2>元编程<a class="headerlink" href="#metaprogramming" title="永久链接至标题">¶</a></h2>
<p>Taichi为元编程提供了基础架构。元编程可以</p>
<ul class="simple">
<li>统一对维度依赖的代码开发，例如2维/3维（2D/3D）物理仿真</li>
<li>通过将运行时开销转移到编译时来提高运行时的性能</li>
<li>简化Taichi标准库的开发</li>
</ul>
<p>Taichi内核是 <em>惰性实例化</em> 的，并且很多有计算可以发生在 <em>编译时</em>。即使没有模板参数，Taichi中的每一个内核也都是模板内核。</p>
<div class="section" id="template-metaprogramming">
<span id="id1"></span><h3>Template metaprogramming<a class="headerlink" href="#template-metaprogramming" title="永久链接至标题">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">y</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="dimensionality-independent-programming-using-grouped-indices">
<h3>使用组合索引（grouped indices）的对维度不依赖的编程<a class="headerlink" href="#dimensionality-independent-programming-using-grouped-indices" title="永久链接至标题">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">y</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">grouped</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">array_op</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">y</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
    <span class="c1"># If tensor x is 2D</span>
    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">grouped</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="c1"># I is a vector of size x.dim() and data type i32</span>
        <span class="n">y</span><span class="p">[</span><span class="n">I</span> <span class="o">+</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># is equivalent to</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span>
</pre></div>
</div>
</div>
<div class="section" id="tensor-size-reflection">
<h3>张量尺寸的反射（size reflection）<a class="headerlink" href="#tensor-size-reflection" title="永久链接至标题">¶</a></h3>
<p>有些时候获取张量的维度（ <code class="docutils literal notranslate"><span class="pre">tensor.dim()</span></code> ）和形状（ <code class="docutils literal notranslate"><span class="pre">tensor.shape()</span></code> ）是很有用的。这些函数既可以被应用在Taichi内核中，也可以被用在Python脚本中。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.func</span>
<span class="k">def</span> <span class="nf">print_tensor_size</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
  <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dim</span><span class="p">())</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dim</span><span class="p">())):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>对稀疏张量而言，此处会返回其完整域的形状（full domain shape）。</p>
</div>
<div class="section" id="compile-time-evaluations">
<h3>编译时求值（Compile-time evaluations）<a class="headerlink" href="#compile-time-evaluations" title="永久链接至标题">¶</a></h3>
<p>Using compile-time evaluation will allow certain computations to happen when kernels are being instantiated.
This saves the overhead of those computations at runtime.</p>
<ul class="simple">
<li>用 <code class="docutils literal notranslate"><span class="pre">ti.static</span></code> 来进行编译时的分支展开（对C++17的用户来说，这相当于是 <a class="reference external" href="https://en.cppreference.com/w/cpp/language/if">if constexpr</a> ）</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">enable_projection</span> <span class="o">=</span> <span class="bp">True</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">static</span><span class="p">():</span>
  <span class="k">if</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="n">enable_projection</span><span class="p">):</span> <span class="c1"># 没有运行时开销</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<ul class="simple">
<li>使用 <code class="docutils literal notranslate"><span class="pre">ti.static</span></code> 强制循环展开（forced loop unrolling）</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">g2p</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">):</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_particles</span><span class="p">):</span>
 <span class="n">base</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv_dx</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span>
 <span class="n">fx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv_dx</span> <span class="o">-</span> <span class="n">ti</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">real</span><span class="p">)</span>
 <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">ti</span><span class="o">.</span><span class="n">sqr</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">-</span> <span class="n">fx</span><span class="p">),</span> <span class="mf">0.75</span> <span class="o">-</span> <span class="n">ti</span><span class="o">.</span><span class="n">sqr</span><span class="p">(</span><span class="n">fx</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">),</span>
      <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ti</span><span class="o">.</span><span class="n">sqr</span><span class="p">(</span><span class="n">fx</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)]</span>
 <span class="n">new_v</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
 <span class="n">new_C</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>

 <span class="c1"># 展开了9次迭代来获得更高的性能</span>
 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
   <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
     <span class="n">dpos</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]),</span> <span class="n">real</span><span class="p">)</span> <span class="o">-</span> <span class="n">fx</span>
     <span class="n">g_v</span> <span class="o">=</span> <span class="n">grid_v_out</span><span class="p">[</span><span class="n">base</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">base</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
     <span class="n">weight</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="mi">1</span><span class="p">)</span>
     <span class="n">new_v</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">g_v</span>
     <span class="n">new_C</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">ti</span><span class="o">.</span><span class="n">outer_product</span><span class="p">(</span><span class="n">g_v</span><span class="p">,</span> <span class="n">dpos</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_dx</span>

 <span class="n">v</span><span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_v</span>
 <span class="n">x</span><span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span>
 <span class="n">C</span><span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_C</span>
</pre></div>
</div>
</div>
<div class="section" id="when-to-use-for-loops-with-ti-static">
<h3>何时使用 <code class="docutils literal notranslate"><span class="pre">ti.static</span></code> 来进行for循环<a class="headerlink" href="#when-to-use-for-loops-with-ti-static" title="永久链接至标题">¶</a></h3>
<p>下面有一些为何应该在for循环的同时使用 <code class="docutils literal notranslate"><span class="pre">ti.static</span></code> 的原因。</p>
<blockquote>
<div><ul class="simple">
<li>循环展开以提高性能。</li>
<li>对向量/矩阵的元素进行循环。矩阵的索引必须为编译时常量。张量的索引可以为运行时变量。例如，如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是由3维向量组成的1维张量，并可以 <code class="docutils literal notranslate"><span class="pre">x[tensor_index][matrix_index]</span></code> 的形式访问。第一个索引（tensor_index）可以是变量，但是第二个索引（matrix_index）必须是一个常量。</li>
</ul>
</div></blockquote>
<p>例如，向量张量（tensor of vectors）的重置代码应该为</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">reset</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
      <span class="c1"># 内层循环必须被展开，因为k是是向量的索引</span>
      <span class="c1"># 而不是全局的张量索引。</span>
      <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
</div>
<span id="document-layout"></span><div class="section" id="advanced-dense-layouts">
<span id="layout"></span><h2>高级数据布局<a class="headerlink" href="#advanced-dense-layouts" title="永久链接至标题">¶</a></h2>
<p>张量（<a class="reference internal" href="index.html#scalar-tensor"><span class="std std-ref">Tensors of scalars</span></a>）可以 <em>放置(place)</em> 在特定的形状和 <em>布局(layout)</em> 中。构造适当的数据布局对性能来说非常关键，特别是对内存密集型的应用程序而言。精心设计的数据布局可以显著提高缓存/ 旁路转换缓冲(TLB)命中率和缓存行(CacheLine)利用率。不过某些情况下性能不是最优先要考虑的因素，因此你可能不需要去担心它。</p>
<p>在 Taichi 中，布局是以递归的方式定义。请参阅 <a class="reference internal" href="index.html#snode"><span class="std std-ref">Structural nodes (SNodes)</span></a> 获得更多关于其工作方式的细节。我们建议从默认的布局规范开始（通过在 <code class="docutils literal notranslate"><span class="pre">ti.var/Vector/Matrix</span></code> 中指定 <code class="docutils literal notranslate"><span class="pre">shape</span></code> 来创建张量），如果需要的话，之后可以再使用 <code class="docutils literal notranslate"><span class="pre">ti.root.X</span></code> 语法迁移到更高级的布局。</p>
<p>Taichi 将算法与数据布局解耦，并且 Taichi 编译器可以自动优化特定数据布局上的数据访问。这些 Taichi 特性使得程序员可以快速尝试不同的数据布局，并找出针对特定任务和计算机体系结构的最有效布局。</p>
<div class="section" id="from-shape-to-ti-root-x">
<h3>由 <code class="docutils literal notranslate"><span class="pre">shape</span></code> 到 <code class="docutils literal notranslate"><span class="pre">ti.root.X</span></code><a class="headerlink" href="#from-shape-to-ti-root-x" title="永久链接至标题">¶</a></h3>
<p>例如，这里声明了一个零维张量：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># 相当于:</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
</pre></div>
</div>
<p>这里声明了一个尺寸为 <code class="docutils literal notranslate"><span class="pre">3</span></code> 的一维张量：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># 相当于:</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>这里声明了一个尺寸为 <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code> 的二维张量：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ij</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># 相当于:</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>你可能会有些疑问，单纯的指定张量的 <code class="docutils literal notranslate"><span class="pre">尺寸(shape)</span></code> 不就行了? 为什么还要使用更为复杂的放置方式? 这是个相当好的问题，接着读下去让我们一起找出原因。</p>
</div>
<div class="section" id="row-major-versus-column-major">
<h3>行优先 vs 列优先<a class="headerlink" href="#row-major-versus-column-major" title="永久链接至标题">¶</a></h3>
<p>让我们先从最简单的布局开始。</p>
<p>由于地址空间在现代计算机结构中是线性排列的，所以对于 Taichi 中的一维张量，第 <code class="docutils literal notranslate"><span class="pre">i</span></code> 个元素的地址就是简单的处于第 <code class="docutils literal notranslate"><span class="pre">i</span></code> 号位置上.</p>
<p>为了存储一个多维张量，必须将它扁平化(flatten)，以适应一维地址空间。例如，要存储一个大小为 <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">2)</span></code> 的二维张量，有两种方法:</p>
<blockquote>
<div><ol class="arabic simple">
<li>第 <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code> 位置的地址是 <code class="docutils literal notranslate"><span class="pre">起始位置</span> <span class="pre">+</span> <span class="pre">i</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">j</span></code> （行优先）。</li>
<li>第 <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code> 位置的地址是 <code class="docutils literal notranslate"><span class="pre">起始位置</span> <span class="pre">+</span> <span class="pre">j</span> <span class="pre">*</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">i</span></code> （列优先）。</li>
</ol>
</div></blockquote>
<p>下面是在 Taichi 中指定使用以上哪种布局的方式:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>    <span class="c1"># 默认行优先</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>    <span class="c1"># 列优先</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code> 和 <code class="docutils literal notranslate"><span class="pre">y</span></code> 的形状都是 <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">2)</span></code> ，访问它们的下标都满足 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">3</span> <span class="pre">&amp;&amp;</span> <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">j</span> <span class="pre">&lt;</span> <span class="pre">2</span></code> 的约束。当然也可以通过相同的下标访问它们: <code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">j]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">y[i,</span> <span class="pre">j]</span></code> 。不过它们有着非常不同的内存布局:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># 存储地址低 ——————————————————————&gt;  存储地址高
# x:  x[0,0]   x[0,1]   x[0,2] | x[1,0]   x[1,1]   x[1,2]
# y:  y[0,0]   y[1,0] | y[0,1]   y[1,1] | y[0,2]   y[1,2]
</pre></div>
</div>
<p>由此可见， <code class="docutils literal notranslate"><span class="pre">x</span></code> 的存储地址首先根据第一个索引下标（即行优先）增加，而 <code class="docutils literal notranslate"><span class="pre">y</span></code> 首先根据第二个索引下标（即列优先）增加。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>对于熟悉 C/C++ 的人来说，这可能看起来像是：</p>
<div class="last highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>  <span class="c1">// 行优先</span>
<span class="kt">int</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>  <span class="c1">// 列优先</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">do_something</span> <span class="p">(</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">);</span>
        <span class="n">do_something</span> <span class="p">(</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="array-of-structures-aos-structure-of-arrays-soa">
<h3>数组结构体(AoS)，结构体数组(SoA)<a class="headerlink" href="#array-of-structures-aos-structure-of-arrays-soa" title="永久链接至标题">¶</a></h3>
<p>同样大小的张量可以被放置到一起。</p>
<p>例如，这里在尺寸为3的一层中放置了两个一维张量（数组结构体，AoS）:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>他们的内存布局：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># 存储地址低 ————————————————————&gt;  存储地址高
#  x[0]   y[0] | x[1]  y[1] | x[2]   y[2]
</pre></div>
</div>
<p>相反的，下列两个张量则被分开放置（结构体数组，SoA）:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>与之对应，它们的内存布局是：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># 存储地址低 ————————————————————&gt;  存储地址高
#  x[0]  x[1]   x[2] | y[0]   y[1]   y[2]
</pre></div>
</div>
<p>通常情况下，您不必担心不同布局之间的性能差别，可以从定义最简单的布局开始。然而，局部性(locality)有时会对性能产生重大影响，尤其是当张量很大的时。</p>
<p><strong>为了改善内存访问的空间局部性(即缓存命中率/ 缓存行利用率)，有时将数据元素放置在相对较近的存储位置（如果它们经常一起被访问的话）会很有帮助。</strong> 以一个简单的一维波动方程的求解为例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">200000</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">vel</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">step</span><span class="p">():</span>
    <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">vel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">k</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>
</pre></div>
</div>
<p>这里，我们将 <code class="docutils literal notranslate"><span class="pre">pos</span></code> 和 <code class="docutils literal notranslate"><span class="pre">vel</span></code> 分开放置。由此 <code class="docutils literal notranslate"><span class="pre">pos[i]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">vel[i]</span></code> 之间地址空间的距离是 <code class="docutils literal notranslate"><span class="pre">200000</span></code> 。这将导致糟糕的空间局部性和大量的缓存缺失(Cache-Misses)，会在很大程度上降低性能。一个更好的放置方案是把它们放置在一起:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">vel</span><span class="p">)</span>
</pre></div>
</div>
<p>将 <code class="docutils literal notranslate"><span class="pre">vel[i]</span></code> 放在 <code class="docutils literal notranslate"><span class="pre">pos[i]</span></code> 旁边，这样就可以提高缓存命中率，从而提高性能。</p>
</div>
<div class="section" id="flat-layouts-versus-hierarchical-layouts">
<h3>平面布局 vs 层次布局<a class="headerlink" href="#flat-layouts-versus-hierarchical-layouts" title="永久链接至标题">¶</a></h3>
<p>默认情况下，当分配一个 <code class="docutils literal notranslate"><span class="pre">ti.var</span></code> 时，它遵循的是最简单的数据布局。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
<span class="c1"># 相当于 C++ 中的: float val[32][64][128]</span>
</pre></div>
</div>
<p>但是，对于计算机图形任务而言，有些时候这种数据布局不是最理想的。 例如，<code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">[i,</span> <span class="pre">j,</span> <span class="pre">k]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">[i</span> <span class="pre">+</span> <span class="pre">1,</span> <span class="pre">j,</span> <span class="pre">k]</span></code> 彼此之间的距离非常远 (<code class="docutils literal notranslate"><span class="pre">32</span> <span class="pre">KB</span></code>)，这导致对于某些计算任务会有着低效的地址访问。 具体而言，在诸如纹理的三线性插值之类任务中，这两个元素甚至不在同一 <code class="docutils literal notranslate"><span class="pre">4KB</span></code> 的页面内，这将产生巨大的缓存/转址旁路缓存压力。</p>
<p>此时更好的布局可能是</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ijk</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ijk</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>这会在 <code class="docutils literal notranslate"><span class="pre">4x4x4</span></code> 模块中放置 <code class="docutils literal notranslate"><span class="pre">val</span></code> ，因此很有可能有 <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">[i,</span> <span class="pre">j,</span> <span class="pre">k]</span></code> 及其邻居在存储上彼此靠近（即，在同一高速缓存行或内存页中） ）。</p>
</div>
<div class="section" id="struct-fors-on-advanced-dense-data-layouts">
<h3>对高级稠密数据布局进行结构 for 循环<a class="headerlink" href="#struct-fors-on-advanced-dense-data-layouts" title="永久链接至标题">¶</a></h3>
<p>在嵌套稠密数据结构上的结构 for 循环将会自动地遵循它们在内存中的数据顺序。例如，如果二维标量张量 <code class="docutils literal notranslate"><span class="pre">A</span></code> 是以行为主的顺序存储的，</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
  <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>将按照行优先的顺序对 <code class="docutils literal notranslate"><span class="pre">A</span></code> 中的元素进行遍历。 如果 <code class="docutils literal notranslate"><span class="pre">A</span></code> 是列优先的，则按照列优先进行遍历。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">A</span></code> 是分层的，则迭代将在层级之间发生。 在大多数情况下，这可以最大化内存带宽利用率。</p>
<p>稀疏张量的结构 for 循环遵循相同的原理，这将在 <a class="reference internal" href="index.html#sparse"><span class="std std-ref">Sparse computation (WIP)</span></a> 中进一步讨论。</p>
</div>
<div class="section" id="examples">
<h3>示例<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h3>
<p>二维矩阵，行优先</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ij</span><span class="p">,</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>二维矩阵，列优先</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ji</span><span class="p">,</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># 注意是 ti.ji 而不是ti.ij</span>
</pre></div>
</div>
<p>按 <cite>8x8</cite> 的大小将 <cite>1024x1024</cite> 的二维数组分块</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">density</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ij</span><span class="p">,</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ij</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
</pre></div>
</div>
<p>三维粒子位置和速度，数组结构体(AoS)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pos</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">vel</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">vel</span><span class="p">)</span>
<span class="c1"># 相当于</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">pos</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">pos</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">pos</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">vel</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">vel</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">vel</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>三维粒子位置和速度，结构体数组(SoA)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pos</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">vel</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
  <span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">pos</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
  <span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">vel</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<span id="document-sparse"></span><div class="section" id="sparse-computation-wip">
<span id="sparse"></span><h2>Sparse computation (WIP)<a class="headerlink" href="#sparse-computation-wip" title="永久链接至标题">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>The Taichi compiler backend is under migration from source-to-source compilation to LLVM for compilation speed and portability.
Sparse computation with the new LLVM backend is not yet fully implemented on multithreaded CPUs and GPUs.</p>
<p>If you are interested in sparse computation in Taichi, please read our <a class="reference external" href="http://taichi.graphics/wp-content/uploads/2019/09/taichi_lang.pdf">paper</a>, watch the <a class="reference external" href="https://www.youtube.com/watch?v=wKw8LMF3Djo">introduction video</a>, or check out
the SIGGRAPH Asia 2019 <a class="reference external" href="http://taichi.graphics/wp-content/uploads/2019/12/taichi_slides.pdf">slides</a>.</p>
<p>The legacy source-to-source backend (commit <code class="docutils literal notranslate"><span class="pre">dc162e11</span></code>) provides full sparse computation functionality. However, since little engineering has been done to make that commit portable (i.e. easy to compile on different platforms),
we suggest waiting until the LLVM version of sparse computation is fully implemented.</p>
<p class="last">Sparse computation functionalities with the new LLVM backend will be back online by the end of December 2019.</p>
</div>
</div>
<span id="document-offset"></span><div class="section" id="coordinate-offsets">
<span id="offset"></span><h2>坐标偏移<a class="headerlink" href="#coordinate-offsets" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>Taichi 张量支持 <strong>坐标偏移(coordinate offsets)</strong> 的定义方式。偏移量会移动张量的边界，使得张量的原点不再是零向量。一个典型的例子是在物理模拟中支持负坐标的体素。</li>
<li>例如，一个大小为 <code class="docutils literal notranslate"><span class="pre">32x64</span></code> 、起始元素坐标偏移为 <code class="docutils literal notranslate"><span class="pre">(-16,</span> <span class="pre">8)</span></code> 的矩阵可以按照以下形式来定义：</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
</pre></div>
</div>
<p>通过这样，张量的下标就是从 <code class="docutils literal notranslate"><span class="pre">(-16,</span> <span class="pre">8)</span></code> 到 <code class="docutils literal notranslate"><span class="pre">(16,</span> <span class="pre">72)</span></code> 了（半开半闭区间）.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">]</span>  <span class="c1"># 左下角</span>
<span class="n">a</span><span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">]</span>   <span class="c1"># 右下角</span>
<span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">64</span><span class="p">]</span>  <span class="c1"># 左上角</span>
<span class="n">a</span><span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">64</span><span class="p">]</span>   <span class="c1"># 右上角</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">张量形状的维数应该与偏移量的维数 <strong>保持一致</strong> 。否则，将引发 <code class="docutils literal notranslate"><span class="pre">AssertionError</span></code>。</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,),</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="p">))</span>          <span class="c1"># 有效!</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">))</span>   <span class="c1"># 有效!</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,))</span>             <span class="c1"># 断言错误</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="p">))</span>       <span class="c1"># 断言错误</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">offset</span><span class="o">=-</span><span class="mi">16</span><span class="p">)</span>                          <span class="c1"># 有效!</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=-</span><span class="mi">16</span><span class="p">)</span>                        <span class="c1"># 断言错误</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">offset</span><span class="o">=-</span><span class="mi">16</span><span class="p">)</span>                    <span class="c1"># 断言错误</span>
</pre></div>
</div>
</div>
<span id="document-differentiable_programming"></span><div class="section" id="differentiable-programming">
<span id="differentiable"></span><h2>可微编程<a class="headerlink" href="#differentiable-programming" title="永久链接至标题">¶</a></h2>
<p>This page is work in progress. Please check out <a class="reference external" href="https://arxiv.org/pdf/1910.00935.pdf">the DiffTaichi paper</a> and <a class="reference external" href="https://www.youtube.com/watch?v=Z1xvAZve9aE">video</a> to learn more about Taichi differentiable programming.</p>
<p><a class="reference external" href="https://github.com/yuanming-hu/difftaichi">DiffTaichi仓库</a> 包含10个使用Taichi可微分编程构建的可微编程物理模拟器。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>与TensorFlow等生成 <strong>不可变</strong> 输出缓冲区的工具不同，Taichi采用的 <strong>命令式</strong> 编程范式允许程序员自由修改全局张量（多维数组）：</p>
<p><strong>全局数据访问规则：</strong></p>
<blockquote>
<div><ul class="simple">
<li>如果全局张量元素被多次写入，则从第二次写入开始，写入 <strong>必须</strong> 以原子加法的形式出现（ <code class="docutils literal notranslate"><span class="pre">累加</span></code>，使用 <code class="docutils literal notranslate"><span class="pre">ti.atomic_add</span></code> 或直接使用 <code class="docutils literal notranslate"><span class="pre">+</span> <span class="pre">=</span></code> ）。</li>
<li>在完成全局张量元素的累加之前，不会对全局张量元素进行读取访问。</li>
</ul>
</div></blockquote>
<p><strong>内核(Kernel)简化规则：</strong> 内核主体由多个 <cite>简单嵌套</cite> 的for循环组成。 即，每个for循环可以只包含一个（嵌套的）for循环（不包含其他语句），也可以包含一组没有循环的语句。</p>
<p>例子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">differentiable_task</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">300</span><span class="p">):</span>
        <span class="o">...</span> <span class="n">do</span> <span class="n">whatever</span> <span class="n">you</span> <span class="n">want</span><span class="p">,</span> <span class="k">as</span> <span class="nb">long</span> <span class="k">as</span> <span class="n">there</span> <span class="n">are</span> <span class="n">no</span> <span class="n">loops</span>

  <span class="c1"># Not allowed. The outer for loop contains two for loops</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
      <span class="o">...</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
      <span class="o">...</span>
</pre></div>
</div>
<p class="last">违反此规则的Taichi程序将在执行梯度运算时产生未定义的行为。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><strong>静态for循环</strong> （例如 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">ti.static(range(4))</span></code> ）将被Python前端预处理器展开，并且不算作循环级别。</p>
</div>
<p>使用微分模拟器和蛮力梯度下降对神经网络控制器进行优化的一些示例：</p>
<img alt="https://github.com/yuanming-hu/public_files/raw/master/learning/difftaichi/ms3_final-cropped.gif" src="https://github.com/yuanming-hu/public_files/raw/master/learning/difftaichi/ms3_final-cropped.gif" />
<img alt="https://github.com/yuanming-hu/public_files/raw/master/learning/difftaichi/rb_final2.gif" src="https://github.com/yuanming-hu/public_files/raw/master/learning/difftaichi/rb_final2.gif" />
<img alt="https://github.com/yuanming-hu/public_files/raw/master/learning/difftaichi/diffmpm3d.gif" src="https://github.com/yuanming-hu/public_files/raw/master/learning/difftaichi/diffmpm3d.gif" />
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Apart from differentiating the simulation time steps, you can also automatically differentiate (negative) potential energies to get forces.
Here is an <a class="reference external" href="https://github.com/taichi-dev/taichi/blob/master/examples/mpm_lagrangian_forces.py">example</a>.</p>
</div>
<p>文档制作中。</p>
</div>
<span id="document-odop"></span><div class="section" id="objective-data-oriented-programming">
<h2>面向数据对象式编程<a class="headerlink" href="#objective-data-oriented-programming" title="永久链接至标题">¶</a></h2>
<p>Taichi是一种 <a class="reference external" href="https://en.wikipedia.org/wiki/Data-oriented_design">面向数据的</a> 编程(DOP)语言。 但是，单纯的DOP会使模块化变得困难。</p>
<p>为了允许代码模块化，Taichi从面向对象编程(OOP)中借鉴了一些概念。</p>
<p>为了方便起见，我们将称此混合方案为 <strong>面向数据对象式编程</strong> (ODOP)。</p>
<p>待办事项：此处应有更多文档。</p>
<p>一个简单的例子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="nd">@ti.data_oriented</span>
<span class="k">class</span> <span class="nc">Array2D</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">increment</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">increment</span> <span class="o">=</span> <span class="n">increment</span>
    <span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ij</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">))</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total</span><span class="p">)</span>

  <span class="nd">@staticmethod</span>
  <span class="nd">@ti.func</span>
  <span class="k">def</span> <span class="nf">clamp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="c1"># Clamp to [0, 1)</span>
      <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

  <span class="nd">@ti.kernel</span>
  <span class="k">def</span> <span class="nf">inc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
      <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">increment</span><span class="p">)</span>

  <span class="nd">@ti.kernel</span>
  <span class="k">def</span> <span class="nf">inc2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">increment</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
      <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">increment</span><span class="p">)</span>

  <span class="nd">@ti.kernel</span>
  <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
      <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">arr</span> <span class="o">=</span> <span class="n">Array2D</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">double_total</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>

<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">lazy_grad</span><span class="p">()</span>

<span class="n">arr</span><span class="o">.</span><span class="n">inc</span><span class="p">()</span>
<span class="n">arr</span><span class="o">.</span><span class="n">inc</span><span class="o">.</span><span class="n">grad</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
<span class="n">arr</span><span class="o">.</span><span class="n">inc2</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">7</span>

<span class="k">with</span> <span class="n">ti</span><span class="o">.</span><span class="n">Tape</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">total</span><span class="p">):</span>
  <span class="n">arr</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">m</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">grad</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">double</span><span class="p">():</span>
  <span class="n">double_total</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">arr</span><span class="o">.</span><span class="n">total</span>

<span class="k">with</span> <span class="n">ti</span><span class="o">.</span><span class="n">Tape</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="n">double_total</span><span class="p">):</span>
  <span class="n">arr</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
  <span class="n">double</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">m</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">grad</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">8</span>
</pre></div>
</div>
</div>
<span id="document-compilation"></span><div class="section" id="the-life-of-a-taichi-kernel">
<span id="compilation"></span><h2>Taichi内核的生命周期<a class="headerlink" href="#the-life-of-a-taichi-kernel" title="永久链接至标题">¶</a></h2>
<p>有时了解Taichi内核的生命周期会有所帮助。 简而言之，编译只会在第一次调用内核实例时发生。</p>
<p>Taichi内核的生命周期如下所示：</p>
<blockquote>
<div><ul class="simple">
<li>内核注册</li>
<li>模板实例化和缓存</li>
<li>Python 抽象语法树转换 (AST: <a class="reference external" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstact Syntax Tree</a> )</li>
<li>Taichi 中间表示代码编译，优化和二进制生成 ( IR: <a class="reference external" href="https://en.wikipedia.org/wiki/Intermediate_representation">Intermediate representation</a> )</li>
<li>启动</li>
</ul>
</div></blockquote>
<img alt="_images/life_of_kernel_lowres.jpg" src="_images/life_of_kernel_lowres.jpg" />
<p>让我们考虑以下简单内核：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">tensor</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">delta</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tensor</span><span class="p">:</span>
    <span class="n">tensor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
</pre></div>
</div>
<p>我们还分配了两个一维张量以简化讨论：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="kernel-registration">
<h3>内核注册<a class="headerlink" href="#kernel-registration" title="永久链接至标题">¶</a></h3>
<p>当执行 <code class="docutils literal notranslate"><span class="pre">ti.kernel</span></code> 装饰器时，将注册一个名为 <code class="docutils literal notranslate"><span class="pre">add</span></code> 的内核。 具体来说，将记住 <code class="docutils literal notranslate"><span class="pre">add</span></code> 函数的Python抽象语法树(AST)。 在第一次调用 <code class="docutils literal notranslate"><span class="pre">add</span></code> 之前不会进行编译。</p>
</div>
<div class="section" id="template-instantiation-and-caching">
<h3>模板实例化和缓存<a class="headerlink" href="#template-instantiation-and-caching" title="永久链接至标题">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<p>第一次调用 <code class="docutils literal notranslate"><span class="pre">add</span></code> 时，Taichi前端编译器将实例化内核。</p>
<p>当你第二次调用相同模板签名（稍后说明）时，例如，</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Taichi将直接重复使用之前编译的二进制文件。</p>
<p>用 <code class="docutils literal notranslate"><span class="pre">ti.template()</span></code> 提示的参数是模板参数，将引起模板实例化。 例如，</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">add</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<p>将导致 <strong>add</strong> 的新实例化。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><strong>模板签名</strong> 可用来区别内核模板的不同实例。 <code class="docutils literal notranslate"><span class="pre">add(x，42)</span></code> 的签名是 <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">ti.i32)</span></code>，与 <code class="docutils literal notranslate"><span class="pre">add(x,</span> <span class="pre">1)</span></code> 的签名相同。 因此，后者可以重复使用先前编译的二进制文件。 <code class="docutils literal notranslate"><span class="pre">add(y,</span> <span class="pre">42</span></code> 的签名是 <code class="docutils literal notranslate"><span class="pre">(y,</span> <span class="pre">ti.i32)</span></code>，与之前签名的值不同，因此将发生新的实例化和编译。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>Taichi标准库中的许多基本操作都是使用Taichi内核实现的， 用以提高性能， 并带有或多或少元编程技巧。调用它们将导致 <strong>隐式内核实例化</strong></p>
<p>示例包括 <code class="docutils literal notranslate"><span class="pre">x.to_numpy()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">y.from_torch(torch_tensor)</span></code>。 调用这些方程时，你将看到内核实例化，因为将生成Taichi内核来把繁重的工作分流给多个CPU内核/ GPU。</p>
<p class="last">如前所述，第二次调用相同的操作时，缓存的已编译内核将被重用，并且不需要进一步的编译。</p>
</div>
</div>
<div class="section" id="code-transformation-and-optimizations">
<h3>代码转换和优化<a class="headerlink" href="#code-transformation-and-optimizations" title="永久链接至标题">¶</a></h3>
<p>当发生新的实例化时，Taichi前端编译器会将内核抽象语法树转换为Python脚本，该脚本在执行时会发出Taichi前端抽象语法树。 基本上，一些补丁已应用于Python 的抽象语法树，以便Taichi前端可以识别它。</p>
<p>AST 的降阶过程 (lowering pass) 会将前端中间表示代码转换为分层静态单任务 (SSA: <a class="reference external" href="https://en.wikipedia.org/wiki/Static_single_assignment_form">Static Single Assignment</a> ) 的中间表示代码，从而可以用更多的过程进一步处理中间表示代码，例如</p>
<blockquote>
<div><ul class="simple">
<li>循环矢量化</li>
<li>类型推断和检查</li>
<li>一般简化，例如通用子表达式消除(CSE)，无效指令消除(DIE)，常数折叠和存储转发</li>
<li>降低访问权限</li>
<li>数据访问优化</li>
<li>反向模式自动微分（如果使用微分编程）</li>
<li>并行化和卸载</li>
<li>原子操作降级</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="the-just-in-time-jit-compilation-engine">
<h3>即时(JIT)编译引擎<a class="headerlink" href="#the-just-in-time-jit-compilation-engine" title="永久链接至标题">¶</a></h3>
<p>最后，经过优化的SSA 中间表示代码被反馈进 LLVM 中间表示代码码元，并且LLVM JIT生成了高性能可执行的 CPU / GPU 程序。</p>
</div>
<div class="section" id="kernel-launching">
<h3>内核启动<a class="headerlink" href="#kernel-launching" title="永久链接至标题">¶</a></h3>
<p>Taichi内核最终将作为多线程CPU任务或CUDA内核启动。</p>
</div>
</div>
<span id="document-syntax_sugars"></span><div class="section" id="syntax-sugars">
<h2>语法糖<a class="headerlink" href="#syntax-sugars" title="永久链接至标题">¶</a></h2>
<div class="section" id="aliases">
<h3>别名<a class="headerlink" href="#aliases" title="永久链接至标题">¶</a></h3>
<p>Creating aliases for global variables and functions with cumbersome names can sometimes improve readability. In Taichi, this can be done by assigning kernel and function local variables with <code class="docutils literal notranslate"><span class="pre">ti.static()</span></code>, which forces Taichi to use standard python pointer assignment.</p>
<p>例如，考虑下面这个简单的内核：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">my_kernel</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tensor_a</span><span class="p">:</span>
    <span class="n">tensor_b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">some_function</span><span class="p">(</span><span class="n">tensor_a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
</pre></div>
</div>
<p>张量和函数使用 <code class="docutils literal notranslate"><span class="pre">ti.static</span></code> 别名为新名称：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">my_kernel</span><span class="p">():</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fun</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="n">tensor_a</span><span class="p">,</span> <span class="n">tensor_b</span><span class="p">,</span> <span class="n">some_function</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
    <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
</pre></div>
</div>
<p>还可以为类成员和方法创建别名，这有助于防止含有 <code class="docutils literal notranslate"><span class="pre">self</span></code> 的面向对象编程代码混乱。</p>
<p>例如，考虑使用类内核来计算某个张量的二维拉普拉斯算子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">compute_laplacian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> \
                <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">ti.static()</span></code> ，这可以简化为：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">compute_laplacian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
    <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> \
           <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p><code class="docutils literal notranslate"><span class="pre">ti.static</span></code> 还可与 <code class="docutils literal notranslate"><span class="pre">if``（编译时分支）和</span> <span class="pre">``for</span></code> （编译时展开）结合使用。 更多相关详细信息，请参见 <a class="reference internal" href="index.html#meta"><span class="std std-ref">Metaprogramming</span></a> 。</p>
<p class="last">在这里，我们将其用于 <em>编译时常量值</em> ，即 <code class="docutils literal notranslate"><span class="pre">张量/函数句柄</span></code> 在编译时是常量。</p>
</div>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-dev_install"></span><div class="section" id="developer-installation">
<span id="dev-install"></span><h2>开发者安装指南<a class="headerlink" href="#developer-installation" title="永久链接至标题">¶</a></h2>
<p>Note this is for the compiler developers of the Taichi programming language.
End users should use the pip packages instead of building from source.
To build with NVIDIA GPU support, CUDA 10.0+ is needed.
This installation guide works for Ubuntu 16.04+ and OS X 10.14+.
For precise build instructions on Windows, please check out <a class="reference external" href="https://github.com/taichi-dev/taichi/blob/master/appveyor.yml">appveyor.yml</a>, which does basically the same thing as the following instructions. We use MSBUILD.exe to build the generated project. Please note that Windows could have multiple instances of MSBUILD.exe shipped with different products. Please make sure you add the path for MSBUILD.exe within your MSVS directory and make it a higher priority (for instance than the one shipped with .NET).</p>
<p>请注意 <code class="docutils literal notranslate"><span class="pre">clang</span></code> 是在Linux/OS X下唯一支持的可以编译Taichi编译器的编译器。而在Windows下只有MSVC是支持的编译器。</p>
<div class="section" id="installing-dependencies">
<h3>Installing Dependencies<a class="headerlink" href="#installing-dependencies" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">请确认你在使用 Python 3.6/3.7/3.8</p>
</li>
<li><p class="first">Install Python dependencies:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3 -m pip install --user setuptools astpretty astor pybind11 Pillow
python3 -m pip install --user pytest pytest-rerunfailures pytest-xdist yapf
python3 -m pip install --user numpy GitPython coverage colorama autograd
</pre></div>
</div>
</li>
<li><p class="first">Make sure you have <code class="docutils literal notranslate"><span class="pre">clang</span></code> with version &gt;= 7</p>
<ul>
<li><p class="first">On Windows: Download <code class="docutils literal notranslate"><span class="pre">clang-8</span></code> via <a class="reference external" href="https://releases.llvm.org/8.0.0/LLVM-8.0.0-win64.exe">this link</a>.
Make sure you add the <code class="docutils literal notranslate"><span class="pre">bin</span></code> folder containing <code class="docutils literal notranslate"><span class="pre">clang.exe</span></code> to the <code class="docutils literal notranslate"><span class="pre">PATH</span></code> environment variable.</p>
</li>
<li><p class="first">On OS X: you don’t need to do anything.</p>
</li>
<li><p class="first">On Ubuntu, execute <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">apt</span> <span class="pre">install</span> <span class="pre">libtinfo-dev</span> <span class="pre">clang-8</span></code>.</p>
</li>
<li><p class="first">On other Linux distributions, please build clang 8.0.1 from source:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget https://github.com/llvm/llvm-project/releases/download/llvmorg-8.0.1/cfe-8.0.1.src.tar.xz
tar xvJf cfe-8.0.1.src.tar.xz
<span class="nb">cd</span> cfe-8.0.1.src
mkdir build
<span class="nb">cd</span> build
cmake ..
make -j <span class="m">8</span>
sudo make install
</pre></div>
</div>
</li>
</ul>
</li>
<li><p class="first">Make sure you have LLVM 8.0.1/10.0.0. Note that Taichi uses a customized LLVM so the pre-built binaries from the LLVM official website or other sources probably doesn’t work.
Here we provide LLVM 8.0.1 binaries customized for Taichi, which may or may not work depending on your system environment:
<a class="reference external" href="https://github.com/yuanming-hu/taichi_assets/releases/download/llvm8/taichi-llvm-8.0.1-linux-x64.zip">Linux</a>,
<a class="reference external" href="https://github.com/yuanming-hu/taichi_assets/releases/download/llvm8/taichi-llvm-8.0.1.zip">OS X</a>,
<a class="reference external" href="https://github.com/yuanming-hu/taichi_assets/releases/download/llvm8/taichi-llvm-8.0.1-msvc2017.zip">Windows</a>.</p>
<blockquote>
<div><p>If the downloaded LLVM does not work, please build from source:</p>
</div></blockquote>
<ul>
<li><p class="first">On Linux or OS X:</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget https://github.com/llvm/llvm-project/releases/download/llvmorg-8.0.1/llvm-8.0.1.src.tar.xz
tar xvJf llvm-8.0.1.src.tar.xz
<span class="nb">cd</span> llvm-8.0.1.src
<span class="c1"># For LLVM 10.0.0:</span>
<span class="c1">#     wget https://github.com/llvm/llvm-project/releases/download/llvmorg-10.0.0/llvm-10.0.0.src.tar.xz</span>
<span class="c1">#     tar xvJf llvm-10.0.0.src.tar.xz</span>
<span class="c1">#     cd llvm-10.0.0.src</span>
mkdir build
<span class="nb">cd</span> build
cmake .. -DLLVM_ENABLE_RTTI:BOOL<span class="o">=</span>ON -DBUILD_SHARED_LIBS:BOOL<span class="o">=</span>OFF -DCMAKE_BUILD_TYPE<span class="o">=</span>Release -DLLVM_TARGETS_TO_BUILD<span class="o">=</span><span class="s2">&quot;X86;NVPTX&quot;</span> -DLLVM_ENABLE_ASSERTIONS<span class="o">=</span>ON
<span class="c1"># If you are building on NVIDIA Jetson TX2, use -DLLVM_TARGETS_TO_BUILD=&quot;ARM;NVPTX&quot;</span>

make -j <span class="m">8</span>
sudo make install

<span class="c1"># Check your LLVM installation</span>
llvm-config --version <span class="c1"># You should get 8.0.1 or 10.0.0</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">On Windows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># LLVM 8.0.1 + MSVC 2017</span>
cmake .. -G<span class="s2">&quot;Visual Studio 15 2017 Win64&quot;</span>  -DLLVM_ENABLE_RTTI:BOOL<span class="o">=</span>ON -DBUILD_SHARED_LIBS:BOOL<span class="o">=</span>OFF -DCMAKE_BUILD_TYPE<span class="o">=</span>Release -DLLVM_TARGETS_TO_BUILD<span class="o">=</span><span class="s2">&quot;X86;NVPTX&quot;</span> -DLLVM_ENABLE_ASSERTIONS<span class="o">=</span>ON -Thost<span class="o">=</span>x64 -DLLVM_BUILD_TESTS:BOOL<span class="o">=</span>OFF -DCMAKE_INSTALL_PREFIX<span class="o">=</span>installed

<span class="c1"># LLVM 10.0.0 + MSVC 2019</span>
cmake .. -G<span class="s2">&quot;Visual Studio 16 2019&quot;</span> -A x64  -DLLVM_ENABLE_RTTI:BOOL<span class="o">=</span>ON -DBUILD_SHARED_LIBS:BOOL<span class="o">=</span>OFF -DCMAKE_BUILD_TYPE<span class="o">=</span>Release -DLLVM_TARGETS_TO_BUILD<span class="o">=</span><span class="s2">&quot;X86;NVPTX&quot;</span> -DLLVM_ENABLE_ASSERTIONS<span class="o">=</span>ON -Thost<span class="o">=</span>x64 -DLLVM_BUILD_TESTS:BOOL<span class="o">=</span>OFF -DCMAKE_INSTALL_PREFIX<span class="o">=</span>installed
</pre></div>
</div>
<ul class="simple">
<li>Then open <code class="docutils literal notranslate"><span class="pre">LLVM.sln</span></code> and use Visual Studio 2017+ to build.</li>
<li>Please make sure you are using the <code class="docutils literal notranslate"><span class="pre">Release</span></code> configuration. After building the <code class="docutils literal notranslate"><span class="pre">INSTALL</span></code> project (under folder <code class="docutils literal notranslate"><span class="pre">CMakePredefinedTargets</span></code> in the Solution Explorer window).</li>
<li>If you use MSVC 2019, <strong>make sure you use C++17</strong> for the <code class="docutils literal notranslate"><span class="pre">INSTALL</span></code> project.</li>
<li>After the build is complete, find your LLVM binaries and headers in <code class="docutils literal notranslate"><span class="pre">build/installed</span></code>.</li>
</ul>
<p>Please add <code class="docutils literal notranslate"><span class="pre">build/installed/bin</span></code> to <code class="docutils literal notranslate"><span class="pre">PATH</span></code>.
Later, when you build Taichi using <code class="docutils literal notranslate"><span class="pre">CMake</span></code>, set <code class="docutils literal notranslate"><span class="pre">LLVM_DIR</span></code> to <code class="docutils literal notranslate"><span class="pre">build/installed/lib/cmake/llvm</span></code>.</p>
</li>
</ul>
</li>
<li><p class="first">On Windows, if you use the pre-built LLVM for Taichi, please add <code class="docutils literal notranslate"><span class="pre">$LLVM_FOLDER/bin</span></code> to <code class="docutils literal notranslate"><span class="pre">PATH</span></code>.
Later, when you build Taichi using <code class="docutils literal notranslate"><span class="pre">CMake</span></code>, set <code class="docutils literal notranslate"><span class="pre">LLVM_DIR</span></code> to <code class="docutils literal notranslate"><span class="pre">$LLVM_FOLDER/lib/cmake/llvm</span></code>.</p>
</li>
</ul>
</div>
<div class="section" id="setting-up-cuda-optional">
<h3>安装并配置CUDA（可选）<a class="headerlink" href="#setting-up-cuda-optional" title="永久链接至标题">¶</a></h3>
<p>如果你没有安装CUDA，请到 <a class="reference external" href="https://developer.nvidia.com/cuda-downloads">英伟达官网</a> 下载安装器。</p>
<ul class="simple">
<li>请运行 <code class="docutils literal notranslate"><span class="pre">nvcc</span> <span class="pre">—version</span></code> 或 <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/usr/local/cuda/version.txt</span></code> 来检查CUDA是否已安装成功。</li>
<li>在 <strong>Ubuntu</strong> 下我们推荐选择 <code class="docutils literal notranslate"><span class="pre">deb</span> <span class="pre">(local)</span></code> 来作为 <strong>安装器类型（Installer Type）</strong>。</li>
<li>在 <strong>Arch Linux</strong> 下，你可以轻松地通过 <code class="docutils literal notranslate"><span class="pre">pacman</span> <span class="pre">-S</span> <span class="pre">cuda</span></code> 来安装CUDA并跳过手动下载安装器的环节。</li>
</ul>
</div>
<div class="section" id="setting-up-taichi-for-development">
<h3>开发者的 Taichi 配置<a class="headerlink" href="#setting-up-taichi-for-development" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">请 <strong>递归地</strong> 克隆 Taichi 代码库，然后构建：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git clone https://github.com/taichi-dev/taichi —depth<span class="o">=</span><span class="m">1</span> —branch<span class="o">=</span>master
git submodule update —init —recursive —depth<span class="o">=</span><span class="m">1</span>
<span class="nb">cd</span> taichi
mkdir build
<span class="nb">cd</span> build
cmake ..
<span class="c1"># if you are building with CUDA 10.0, use the line below:</span>
<span class="c1"># 如果你正在构建支持CUDA 10.0的版本，使用下面这行来运行cmake</span>
<span class="c1">#   cmake .. -DCUDA_VERSION=10.0 -DTI_WITH_CUDA:BOOL=True</span>
make -j <span class="m">8</span>
</pre></div>
</div>
</li>
<li><p class="first">将下面的脚本添加至你的 <code class="docutils literal notranslate"><span class="pre">~/.bashrc</span></code> 配置文件：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">TAICHI_REPO_DIR</span><span class="o">=</span>/home/XXX/taichi  <span class="c1"># Path to your taichi repository</span>
<span class="nb">export</span> <span class="nv">PYTHONPATH</span><span class="o">=</span><span class="nv">$TAICHI_REPO_DIR</span>/python/:<span class="nv">$PYTHONPATH</span>
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$TAICHI_REPO_DIR</span>/bin/:<span class="nv">$PATH</span>
<span class="c1"># export PATH=/opt/llvm/bin:$PATH # 反注释这行如果你的llvm-8或clang-8在/opt目录下</span>
</pre></div>
</div>
</li>
<li><p class="first">执行 <code class="docutils literal notranslate"><span class="pre">source</span> <span class="pre">~/.bashrc</span></code> 来重载shell的配置。</p>
</li>
<li><p class="first">执行 <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">-m</span> <span class="pre">taichi</span> <span class="pre">test</span></code> 来运行所有的测试。运行所有测试用例可能会耗费长达5分钟的时间。</p>
</li>
<li><p class="first">查看 <code class="docutils literal notranslate"><span class="pre">examples</span></code> 下的可执行的示例。使用 <code class="docutils literal notranslate"><span class="pre">python3</span></code> 来运行它们。</p>
</li>
</ul>
</div>
<div class="section" id="troubleshooting">
<h3>故障排除<a class="headerlink" href="#troubleshooting" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>在调试模式（debug mode）下运行以检查是否有任何的非法内存访问</li>
<li>禁用编译器优化来快速确认问题并非是由优化引起的</li>
</ul>
</div>
</div>
<span id="document-contributor_guide"></span><div class="section" id="contribution-guidelines">
<h2>开发与贡献指南<a class="headerlink" href="#contribution-guidelines" title="永久链接至标题">¶</a></h2>
<p>首先，感谢你的参与和贡献！我们欢迎一切形式的贡献，包括但不限于</p>
<ul class="simple">
<li>修复 BUG</li>
<li>提出和实现新功能</li>
<li>对本文档进行改进和翻译（欢迎前往 <a class="reference external" href="https://github.com/taichi-dev/taichi-docs-zh-cn">Taichi 中文文档</a>）</li>
<li>完善错误时的提示，使之对用户更友好</li>
<li>提交新的测试用例</li>
<li>提交新的样例程序</li>
<li>提交编译器性能补丁</li>
<li>发布有关 Taichi 的博客文章和教程</li>
<li>加入我们的 <a class="reference external" href="https://forum.taichi.graphics/">Taichi 论坛</a></li>
<li>向你的朋友们介绍 Taichi 或者直接在 GitHub 上星标 <a class="reference external" href="https://github.com/taichi-dev/taichi">Taichi</a> 也可以。</li>
<li>修复文档，代码，注释中的拼写错误（像这样的小问题请直接创建一个 PR 而不必开一个 issue）</li>
</ul>
<div class="section" id="how-to-contribute-bug-fixes-and-new-features">
<h3>如何参与 BUG 修复，添加新特性<a class="headerlink" href="#how-to-contribute-bug-fixes-and-new-features" title="永久链接至标题">¶</a></h3>
<p>标记了 <a class="reference external" href="https://github.com/taichi-dev/taichi/issues?q=is%3Aopen+is%3Aissue+label%3A%22welcome+contribution%22">“good first issue”</a> 的 issue 是较容易上手的。</p>
<ul class="simple">
<li>请先在这个 issue 中留下一句评论（比如： <em>我知道怎么解决这个，我乐意帮忙！</em> ）。这样大家就知道已经有人在解决这个问题了，从而避免重复劳动;</li>
<li>如果没有核心开发成员说明一个 issue 可能的解决方案，请简要地描述你的方案，并在你开始之前静候开发成员的回复，从而保障实现的简洁高效。</li>
</ul>
<p>标记了 <a class="reference external" href="https://github.com/taichi-dev/taichi/issues?q=is%3Aopen+is%3Aissue+label%3A%22welcome+contribution%22">“welcome contribution”</a> 的 issue 相比之下更有挑战性但对新手仍然是比较友好的。</p>
</div>
<div class="section" id="high-level-guidelines">
<h3>进阶指导<a class="headerlink" href="#high-level-guidelines" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>切实解决问题是我们的最终目标。</li>
<li>不要小题大做：用 <em>简单</em> 的方案去解决简单的问题，这样你可以抽出时间和精力处理那些真正困难的问题。</li>
<li>几乎每一个设计都有两面性。如果利大于弊，那就可以看作是一个 <em>好的决定</em> ，请务必权衡利弊。</li>
<li>调试是很困难的，每一次的改动应该很小，这样 BUG 的源头就可以很容易地找到。</li>
<li>单元/集成测试是我们的好伙伴。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">“软件设计过程中中存在两种模式：一种是使之结构简单明了到没有任何问题，另一种是令结构设计足够复杂到完美无缺 <cite>而第一种方案则要困难的多</cite>.”     — <a class="reference external" href="https://en.wikipedia.org/wiki/Tony_Hoare">C.A.R. 霍尔</a></p>
</div>
<p>需要记住的一点是，Taichi 最初作为一个学术研究项目而诞生。这通常意味着有些部分没有机会经过稳固坚实的设计。虽然我们一直在努力提高代码质量，但这并不意味着项目能没有技术负债。有些地方仍可能会过于复杂而让人感到困惑。一旦你发现这种情形的存在，非常欢迎给我们提出 PR！:-)</p>
</div>
<div class="section" id="effective-communication">
<h3>高效率地沟通<a class="headerlink" href="#effective-communication" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>传达了多少有效信息，比打了多少字重要的多。</li>
<li>在沟通中保持积极，礼貌，注意语言的组织性、准确性。</li>
<li>注意除了文字之外，列表(Bulleted lists)也是我们表达过程中的好伙伴。</li>
<li>提交评论前请仔细预读：如果你是读者，你能读懂自己所写的内容么？</li>
<li>如果你的母语不是英语，考虑使用拼写检查器，如 <a class="reference external" href="https://app.grammarly.com/">Grammarly</a> 。</li>
</ul>
<p>请根据事实进行讨论与反馈，而不是个人感觉。对我们所有人来说，保持一个友好、零责备的社区环境是非常重要的。一些例子如下:</p>
<div class="admonition tip">
<p class="first admonition-title">小技巧</p>
<p class="last">（可接受的表达方式）这种设计可能会让 Taichi 的初学者感到困惑。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">（不可接受的表达方式）这种设计真是太糟糕了。</p>
</div>
</div>
<div class="section" id="making-good-pull-requests">
<h3>提交良好的 PR<a class="headerlink" href="#making-good-pull-requests" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>我们鼓励改动很小的 PR， 一个 PR 理想情况下应该 <strong>只针对一个问题(issue)</strong> 。<ul>
<li>也可以掺杂一些 <strong>无关紧要</strong> 的优化重构，比如修正笔误;</li>
<li>审稿人保留要求 PR 作者删除一些 <strong>无关紧要</strong> 的改动的权利。</li>
</ul>
</li>
<li>PR 中的所有 commit 都应被 <strong>压缩&amp;合并到 master 分支的一个 commit 里</strong> 。</li>
<li>为保留清晰的提交日志 PR 作者 <strong>不应该将多条 commit 压缩(squash)后提交</strong>;</li>
<li>当实现一个复杂的特性时，考虑将其分散为许多个小 PR，从而保证更具细节的开发时间线，保证与开发者更频繁的沟通。</li>
<li>如果你想更及时的得到核心开发成员的反馈<ul>
<li>通过 GitHub 的 <a class="reference external" href="https://github.blog/2019-02-14-introducing-draft-pull-requests/">Draft</a> 状态开一个 PR，这样就可以和我们实时分享你的进展了;</li>
<li>请确保在评论中 &#64; 相应开发成员，或者使用请求评审(request the review)。</li>
</ul>
</li>
<li>如果你同时在处理多个 PR<ul>
<li>互不依赖的 PR 都应该是基于 <code class="docutils literal notranslate"><span class="pre">master</span></code> 衍生出的 <strong>不同</strong> 分支;</li>
<li>互相依赖的 PR 应该在所有前置 PR 合并入 <code class="docutils literal notranslate"><span class="pre">master</span></code> 后再进行提出。</li>
</ul>
</li>
<li>所有 PR 理想情况下都应该伴随着相应的 <strong>测试</strong>;</li>
<li>除了内部编译器的实现外，其余的 PR 都应该带有与其功能相对应的 <strong>文档更新(documentation update)</strong>;</li>
<li>所有 PR 必须通过 <strong>持续集成测试(continuous integration tests)</strong> 后才能被合并;</li>
<li>PR 的标题应当按照 <a class="reference internal" href="index.html#prtag"><span class="std std-ref">PR title format and tags</span></a> 的要求编写;</li>
<li>除此之外，谷歌有篇相当棒的文章 <a class="reference external" href="https://testing.googleblog.com/2017/06/code-health-too-many-comments-on-your.html">how to have your PR merged quickly</a>. <a class="reference external" href="https://github.com/yuanming-hu/public_files/blob/master/graphics/taichi/google_review_comments.pdf">[PDF]</a> 可供参考</li>
</ul>
</div>
<div class="section" id="reviewing-pr-merging">
<h3>审核与 PR 的合并<a class="headerlink" href="#reviewing-pr-merging" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>请按照以下几个来自谷歌的建议<ul>
<li><a class="reference external" href="https://testing.googleblog.com/2018/05/code-health-understanding-code-in-review.html">Code Health: Understanding Code In Review</a>; <a class="reference external" href="https://github.com/yuanming-hu/public_files/blob/master/graphics/taichi/google_understanding_code.pdf">[PDF]</a></li>
<li><a class="reference external" href="https://testing.googleblog.com/2019/11/code-health-respectful-reviews-useful.html">Code Health: Respectful Reviews == Useful Reviews</a>. <a class="reference external" href="https://github.com/yuanming-hu/public_files/blob/master/graphics/taichi/google_respectful_reviews.pdf">[PDF]</a></li>
</ul>
</li>
<li>合并操作应当始终将 PR <strong>压缩&amp;合并</strong> 到主分支（默认为master）上;</li>
<li>主分支要求记录 <strong>线性历史</strong>;</li>
<li>确保 PR 能够顺利通过 <strong>持续集成测试</strong>，文档更新等情况除外;</li>
<li>确保标题遵循 <a class="reference internal" href="index.html#prtag"><span class="std std-ref">PR title format and tags</span></a> 的要求。</li>
</ul>
</div>
<div class="section" id="using-continuous-integration">
<h3>持续集成的运用<a class="headerlink" href="#using-continuous-integration" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>持续集成(Continuous Integration,CI)，将在 CI 环境中 <strong>构建(build)</strong> 和 <strong>测试(test)</strong> 你所提交的 PR。</li>
<li>目前，Taichi 使用的集成测试服务是 <a class="reference external" href="https://travis-ci.org">Travis CI</a> (OS X 和 Linux 平台)和 <a class="reference external" href="https://www.appveyor.com">AppVeyor</a> (Windows 平台)。</li>
<li>每次你推送提交到一个开着的 PR 时，CI 将被触发。</li>
<li>可以在提交消息前加上 <code class="docutils literal notranslate"><span class="pre">[skip</span> <span class="pre">ci]</span></code> 以避免触发 CI。例如：<a href="#id1"><span class="problematic" id="id2">``</span></a>[skip ci] This commit will not trigger CI`</li>
<li>提交 ID 右侧有绿色对勾表示 CI 通过，红色叉号表示 CI 失败。</li>
</ul>
</div>
<div class="section" id="enforcing-code-style">
<h3>规范代码结构<a class="headerlink" href="#enforcing-code-style" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">在本地，可以通过在命令行中运行 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">format</span></code> 来自动格式化代码。请注意，在使用 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">format</span></code> 之前，您必须在本地安装 <code class="docutils literal notranslate"><span class="pre">clang-format-6.0</span></code> 和 <code class="docutils literal notranslate"><span class="pre">yapf</span> <span class="pre">v0.29.0</span></code> 。</p>
</li>
<li><p class="first">如果不想在本地安装这些格式化工具，也可以使用 <strong>格式化服务器(format server)</strong> 。这是个 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">format</span></code> 的在线版本。</p>
<blockquote>
<div><ul class="simple">
<li>访问 <a class="reference external" href="http://kun.csail.mit.edu:31415/">http://kun.csail.mit.edu:31415/</a>，并点击选取所需格式化的 PR id。</li>
<li>回到 PR 页面，你将看到一个名为 &#64;taichi-gardener (机器人) 的用户推送了一个名为 <code class="docutils literal notranslate"><span class="pre">[skip</span> <span class="pre">ci]</span> <span class="pre">enforce</span> <span class="pre">code</span> <span class="pre">format</span></code> 的提交。</li>
<li>如果你没能找到机器人的提交，说明没有发现任何不规范的代码格式，。</li>
<li>然后在本地分支中运行 <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">pull</span></code> 来提取格式化代码。</li>
<li>值得留意的是，备注带有为 <code class="docutils literal notranslate"><span class="pre">[format]</span></code> 的提交信息将自动触发格式化服务。例如：<code class="docutils literal notranslate"><span class="pre">[format]</span> <span class="pre">our</span> <span class="pre">commit</span> <span class="pre">message</span></code></li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="pr-title-format-and-tags">
<span id="prtag"></span><h3>PR 标题格式和标签<a class="headerlink" href="#pr-title-format-and-tags" title="永久链接至标题">¶</a></h3>
<p>PR 标题将成为 <code class="docutils literal notranslate"><span class="pre">master</span></code> 分支中提交历史的一部分，因此保证 PR 标题的可读性非常重要。</p>
<blockquote>
<div><ul>
<li><p class="first">请务必在 PR 标题前附加上至少一个标签，如 <code class="docutils literal notranslate"><span class="pre">[Metal]</span></code> 等:</p>
<blockquote>
<div><ul class="simple">
<li>当使用多个标签时，确保标签之间只留有一个空格分隔;</li>
<li>例如， <code class="docutils literal notranslate"><span class="pre">[Metal][refactor]``（没有空格）应该被格式化为</span> <span class="pre">``[Metal]</span> <span class="pre">[refactor]</span></code>;</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">PR 标题主干部分的首字母应该大写：</p>
<blockquote>
<div><ul class="simple">
<li>例如， <code class="docutils literal notranslate"><span class="pre">[doc]</span> <span class="pre">improve</span> <span class="pre">documentation</span></code> 应该被格式化为 <code class="docutils literal notranslate"><span class="pre">[doc]</span> <span class="pre">Improve</span> <span class="pre">documentation</span></code>;</li>
<li>同时， <code class="docutils literal notranslate"><span class="pre">[Lang]</span> <span class="pre">“ti.sqr(x)”</span> <span class="pre">is</span> <span class="pre">now</span> <span class="pre">deprecated</span></code> 是可以的，因为 <code class="docutils literal notranslate"><span class="pre">“</span></code> 是一个符号。</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">请不要在 PR 标题中包括反引号 (“`”)。</p>
</li>
<li><p class="first">例如，“[Metal] Support bitmasked SNode”，“[OpenGL] AtomicMin/Max support”，或 “[Opt] [IR] Enhanced constant folding”。</p>
</li>
</ul>
</div></blockquote>
<p>常用的标签:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">[Metal],</span> <span class="pre">[OpenGL],</span> <span class="pre">[CPU],</span> <span class="pre">[CUDA],</span> <span class="pre">[LLVM]</span></code>: 后端;</li>
<li><code class="docutils literal notranslate"><span class="pre">[LLVM]</span></code>: CPU 和 CUDA 共享的 LLVM 后端;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Lang]</span></code>: 前端语法特性，包括语法糖;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Std]</span></code>: 标准库，例如 <code class="docutils literal notranslate"><span class="pre">ti.Matrix</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ti.Vector</span></code>;</li>
<li><code class="docutils literal notranslate"><span class="pre">[IR]</span></code>: 中间表示(intermediate representation, IR);</li>
<li><code class="docutils literal notranslate"><span class="pre">[Opt]</span></code>: IR 优化迭代轮数;</li>
<li><code class="docutils literal notranslate"><span class="pre">[GUI]</span></code>: 内嵌的 GUI 系统;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Refactor]</span></code>: 代码重构优化;</li>
<li><code class="docutils literal notranslate"><span class="pre">[CLI]</span></code>: 命令行接口， 例如 <code class="docutils literal notranslate"><span class="pre">ti</span></code> 命令;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Doc]</span></code>: 与 <code class="docutils literal notranslate"><span class="pre">docs/</span></code> 目录下的文档相关;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Example]</span></code>: 与 <code class="docutils literal notranslate"><span class="pre">examples/</span></code> 目录下的样例程序相关;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Test]</span></code>: 与 <code class="docutils literal notranslate"><span class="pre">tests/</span></code> 目录下增加和改进测试程序相关;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Linux]</span></code>: 与Linux 平台有关;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Mac]</span></code>: 与Mac OS X 平台有关;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Windows]</span></code>: 与Windows 平台有关;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Perf]</span></code>: 性能改进;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Misc]</span></code>: 难以归类的杂项，如版本跳跃，格式优化;</li>
<li><code class="docutils literal notranslate"><span class="pre">[Bug]</span></code>: 修复 Bug;</li>
<li>在 <a class="reference external" href="https://github.com/taichi-dev/taichi/blob/master/misc/prtags.json">misc/prtags.json</a> 中查看更多标签.</li>
<li>在引进新标签时，请在首先使用该标签的 PR 中一并更新 <code class="docutils literal notranslate"><span class="pre">misc/prtags.json</span></code> 列表，以便其余成员跟随使用。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>我们感谢所有的贡献，但是我们不应该把每一个 PR 的标题暴露给终端用户。因此，应该将变更日志分类成 <cite>用户应该知道什么</cite> 和 <cite>开发人员正在做什么</cite> 是必要的。而这是通过 <strong>大写 PR 标签</strong> 区分的:</p>
<blockquote class="last">
<div><ul class="simple">
<li>对用户可见/值得注意的 PR，应该将其一开始的标签以 <strong>大写的首字母</strong> 进行标记，例如 <code class="docutils literal notranslate"><span class="pre">[Metal],</span> <span class="pre">[OpenGL],</span> <span class="pre">[IR],</span> <span class="pre">[Lang],</span> <span class="pre">[CLI]</span></code>。在发布新版本时，脚本(<code class="docutils literal notranslate"><span class="pre">python/taichi/make_changelog.py</span></code>)将生成一个突出显示这些更改（PR 标题）的变更日志。因此，确保终端用户能够理解你的 PR 所做的工作是非常 <strong>重要</strong> 的，而这都是 <strong>基于你的PR标题</strong>。</li>
<li>其他类型的 PR（底层开发/中间实现）应该使用 <strong>全小写字母</strong> 的标签 ：例如 <code class="docutils literal notranslate"><span class="pre">[metal],</span> <span class="pre">[opengl],</span> <span class="pre">[ir],</span> <span class="pre">[lang],</span> <span class="pre">[cli]</span></code>。</li>
<li>由于发布更新日志的生成方式，PR 标题中应该 <strong>最多只有一个大写标记</strong>，以防止重复的 PR 突出显示。例如， <code class="docutils literal notranslate"><span class="pre">[GUI]</span> <span class="pre">[Mac]</span> <span class="pre">Support</span> <span class="pre">modifier</span> <span class="pre">keys</span></code> (#1189) 就是一个反例, 我们应该用 <code class="docutils literal notranslate"><span class="pre">[gui]</span> <span class="pre">[Mac]</span> <span class="pre">Support</span> <span class="pre">modifier</span> <span class="pre">keys</span> <span class="pre">in</span> <span class="pre">GUI</span></code> 来替代。 请只大写与 PR 内容最相关的标签。</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="tips-on-the-taichi-compiler-development">
<h3>Taichi 编译器的开发建议<a class="headerlink" href="#tips-on-the-taichi-compiler-development" title="永久链接至标题">¶</a></h3>
<p>阅读 <a class="reference internal" href="index.html#compilation"><span class="std std-ref">The life of a Taichi kernel</span></a> 这一章也许有助于你理解我们的工作。它解释了整个编译过程。</p>
<p>如果你的工作涉及 IR 优化，请参见 <a class="reference internal" href="index.html#regress"><span class="std std-ref">基准测试和回归测试</span></a> 。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">ti.init(arch=desired_arch,</span> <span class="pre">**kwargs)</span></code> 创建 Taichi 程序时，传入以下参数，可以使 Taichi 编译器打印出 IR:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">print_preprocessed</span> <span class="pre">=</span> <span class="pre">True</span></code>：打印前端 Python AST 转换的结果。结果脚本(resulting scripts)在执行时将生成一个 Taichi 前端 AST。</li>
<li><code class="docutils literal notranslate"><span class="pre">print_ir</span> <span class="pre">=</span> <span class="pre">True</span></code>：打印内核编译（不包括访问器）中的 Taichi IR 转换过程。</li>
<li><code class="docutils literal notranslate"><span class="pre">print_accessor_ir</span> <span class="pre">=</span> <span class="pre">True</span></code>：打印数据访问器的 IR 转换过程，这是一种特殊而简单的内核信息。（不过很少使用，除非你正在调试数据访问器相关的编译）</li>
<li><code class="docutils literal notranslate"><span class="pre">print_struct_llvm_ir</span> <span class="pre">=</span> <span class="pre">True</span></code>: 保存由 Taichi 结构编译器生成的 LLVM IR。</li>
<li><code class="docutils literal notranslate"><span class="pre">print_kernel_llvm_ir</span> <span class="pre">=</span> <span class="pre">True</span></code>: 保存由 Taichi 内核编译器生成的 LLVM IR。</li>
<li><code class="docutils literal notranslate"><span class="pre">print_kernel_llvm_ir_optimized</span> <span class="pre">=</span> <span class="pre">True</span></code>：保存每个内核优化的 LLVM IR。</li>
<li><code class="docutils literal notranslate"><span class="pre">print_kernel_nvptx</span> <span class="pre">=</span> <span class="pre">True</span></code>：保存每个内核生成的 NVPTX（仅限 CUDA）。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Python 作用域中的数据访问器被实现为特殊的 Taichi 内核。例如，<code class="docutils literal notranslate"><span class="pre">x[1,</span> <span class="pre">2,</span> <span class="pre">3]</span> <span class="pre">=</span> <span class="pre">3</span></code> 将调用 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的写访问器内核， <code class="docutils literal notranslate"><span class="pre">print(y[42])</span></code> 将调用 <code class="docutils literal notranslate"><span class="pre">y</span></code> 的读访问器内核。</p>
</div>
</div>
<div class="section" id="testing">
<h3>测试<a class="headerlink" href="#testing" title="永久链接至标题">¶</a></h3>
<p>测试程序应该添加到文件夹 <code class="docutils literal notranslate"><span class="pre">taichi/tests</span></code> 下。</p>
<ul class="simple">
<li>通过使用 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span></code> 运行所有测试实例。</li>
<li>通过使用 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">-v</span></code> 查看详细输出信息。</li>
<li>通过使用 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">-C</span></code> 运行测试并记录代码覆盖率, 参阅 <a class="reference internal" href="index.html#coverage"><span class="std std-ref">Code coverage</span></a> 查看更多信息.</li>
<li>使用 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">&lt;filename(s)&gt;</span></code> 运行特定的测试实例。除此之外诸如，<code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">numpy_io</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">test_numpy_io.py</span></code> 的写法是等价的。</li>
<li>使用 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">-a</span> <span class="pre">&lt;arch(s)&gt;</span></code> 针对指定架构进行测试。例如，<code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">-a</span> <span class="pre">opengl</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">numpy_io</span> <span class="pre">-a</span> <span class="pre">cuda,metal</span></code>。</li>
<li>使用 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">-na</span> <span class="pre">&lt;arch(s)&gt;</span></code> 测试除指定架构外的其余所有架构。例如，<code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">-na</span> <span class="pre">opengl,cuda</span></code>。</li>
<li>使用 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">-c</span></code> 运行 C++ 测试程序。例如， <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">-c</span> <span class="pre">alg_simp</span></code></li>
</ul>
<p>或者使用 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span> <span class="pre">-h</span></code> 查看更多选项。</p>
</div>
<div class="section" id="documentation">
<h3>文档<a class="headerlink" href="#documentation" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>使用 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">doc</span></code> 建立本地文档。</li>
<li>在目录 <code class="docutils literal notranslate"><span class="pre">taichi/doc/build/index.html</span></code> 下打开文档。</li>
<li>在 Linux/OS X 下, 使用 <code class="docutils literal notranslate"><span class="pre">watch</span> <span class="pre">-n</span> <span class="pre">1</span> <span class="pre">ti</span> <span class="pre">doc</span></code> 以持续地构建文档。<ul>
<li>如果 OpenGL 后端检测器一直在创建新窗口，对 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">doc</span></code> 附加执行 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_WITH_OPENGL=0</span></code> 。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="c-and-python-standards">
<h3>C++ 和 Python 标准<a class="headerlink" href="#c-and-python-standards" title="永久链接至标题">¶</a></h3>
<p>Taichi 的 C++ 模块是基于 C++ 17编写的，Python 模块是基于3.6+编写的。所以你可以合理认为 C++ 17和 Python 3.6 特性总是可用的。</p>
</div>
<div class="section" id="efficient-code-navigation-across-python-c">
<h3>跨 Python/C++ 的高效代码导航<a class="headerlink" href="#efficient-code-navigation-across-python-c" title="永久链接至标题">¶</a></h3>
<p>如果你使用的是前端语言（Python/C++接口），要在代码库中导航，<a class="reference external" href="https://github.com/tqchen/ffi-navigator">ffi-navigator</a> 允许从 Python 跳转到它们在 C++ 中绑定的定义。按照前述链接的 README 设置你的编辑器。</p>
</div>
<div class="section" id="folder-structure">
<h3>目录结构<a class="headerlink" href="#folder-structure" title="永久链接至标题">¶</a></h3>
<p>关键文件包括</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">taichi</span></code>: 核心编译器实现<ul>
<li><code class="docutils literal notranslate"><span class="pre">analysis</span></code>: 静态分析</li>
<li><code class="docutils literal notranslate"><span class="pre">backends</span></code>: 基于设备的代码生成/运行时环境</li>
<li><code class="docutils literal notranslate"><span class="pre">codegen</span></code>: 代码生成基类</li>
<li><code class="docutils literal notranslate"><span class="pre">gui</span></code>: 图形用户界面</li>
<li><code class="docutils literal notranslate"><span class="pre">inc</span></code>: 需要重复引用的定义文件</li>
<li><code class="docutils literal notranslate"><span class="pre">ir</span></code>: 中间表示</li>
<li><code class="docutils literal notranslate"><span class="pre">jit</span></code>: 实时(Just-in-Time, JIT)编译器基类</li>
<li><code class="docutils literal notranslate"><span class="pre">llvm</span></code>: LLVM 相关实用程序</li>
<li><code class="docutils literal notranslate"><span class="pre">math</span></code>: 数学类相关实用程序</li>
<li><code class="docutils literal notranslate"><span class="pre">platform</span></code>: 平台支持依赖</li>
<li><code class="docutils literal notranslate"><span class="pre">program</span></code>: 上层结构</li>
<li><code class="docutils literal notranslate"><span class="pre">python</span></code>: C++/Python 接口</li>
<li><code class="docutils literal notranslate"><span class="pre">runtime</span></code>: 运行环境</li>
<li><code class="docutils literal notranslate"><span class="pre">struct</span></code>:  结构编译器基类</li>
<li><code class="docutils literal notranslate"><span class="pre">system</span></code>: 操作系统相关的基础结构</li>
<li><code class="docutils literal notranslate"><span class="pre">transforms</span></code>: IR 转换传递(Passes)</li>
<li><code class="docutils literal notranslate"><span class="pre">util</span></code>: 各种各样的工具</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">python</span></code>: Python 前端实现</li>
<li><code class="docutils literal notranslate"><span class="pre">examples</span></code>: 样例程序</li>
<li><code class="docutils literal notranslate"><span class="pre">docs</span></code>: 文档</li>
<li><code class="docutils literal notranslate"><span class="pre">tests</span></code>: C++ 和 Python 测试程序</li>
<li><code class="docutils literal notranslate"><span class="pre">benchmarks</span></code>: 性能基准</li>
<li><code class="docutils literal notranslate"><span class="pre">misc</span></code>: 零散（但仍很有用）的文件</li>
<li>…</li>
</ul>
</div>
<div class="section" id="upgrading-cuda">
<h3>升级 CUDA<a class="headerlink" href="#upgrading-cuda" title="永久链接至标题">¶</a></h3>
<p>目前我们的开发工作是针对 CUDA 10。在升级 CUDA 版本时，当前 <code class="docutils literal notranslate"><span class="pre">external/cuda_libdevice/slim_libdevice.10.bc</span></code> 文件应该被新的版本的所取代。</p>
<p>基于 CUDA 安装时整个 <code class="docutils literal notranslate"><span class="pre">libdevice.X.bc</span></code> 文件，使用 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">run</span> <span class="pre">make_slim_libdevice</span> <span class="pre">[libdevice.X.bc</span> <span class="pre">file]</span></code> 生成精简版的 libdevice</p>
</div>
</div>
<span id="document-utilities"></span><div class="section" id="developer-utilities">
<h2>开发者工具<a class="headerlink" href="#developer-utilities" title="永久链接至标题">¶</a></h2>
<div class="section" id="logging">
<h3>日志<a class="headerlink" href="#logging" title="永久链接至标题">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">level can be {}</span>
<span class="sd">    ti.TRACE</span>
<span class="sd">    ti.DEBUG</span>
<span class="sd">    ti.INFO</span>
<span class="sd">    ti.WARN</span>
<span class="sd">    ti.ERR</span>
<span class="sd">    ti.CRITICAL</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="n">ti</span><span class="o">.</span><span class="n">set_logging_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
</pre></div>
</div>
<p>默认日志记录级别为 <code class="docutils literal notranslate"><span class="pre">ti.INFO</span></code>。 你还可以通过将环境变量 <code class="docutils literal notranslate"><span class="pre">TI_LOG_LEVEL</span></code> 设置为诸如 <code class="docutils literal notranslate"><span class="pre">trace</span></code> 和 <code class="docutils literal notranslate"><span class="pre">warn</span></code> 之类的值来覆盖默认日志记录级别。</p>
</div>
<div class="section" id="benchmarking-and-regression-tests">
<span id="regress"></span><h3>基准测试和回归测试<a class="headerlink" href="#benchmarking-and-regression-tests" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>运行 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">benchmark</span></code> 以基准模式运行测试。 这将记录 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">test</span></code> 的性能，并将其保存在 <code class="docutils literal notranslate"><span class="pre">benchmarks/output</span></code> 中。</li>
<li>运行 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">regression</span></code> 以显示 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">regression</span></code> 中先前结果之间的差异。 你可以查看提交后性能是提高还是降低。 当你的工作与中间表示码优化相关时，这很有帮助。</li>
<li>运行 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">baseline</span></code> 以将基准结果保存到 <code class="docutils literal notranslate"><span class="pre">benchmarks/baseline</span></code> 以供将来比较，这可以在与性能有关的PR上执行，然后再合并到master中。</li>
</ul>
<p>例如，这是启用常数折叠优化传递后 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">regression</span></code> 输出的一部分：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>linalg__________________polar_decomp______________________________
codegen_offloaded_tasks                       37 -&gt;    39    +5.4%
codegen_statements                          3179 -&gt;  3162    -0.5%
codegen_kernel_statements                   2819 -&gt;  2788    -1.1%
codegen_evaluator_statements                   0 -&gt;    14    +inf%

linalg__________________init_matrix_from_vectors__________________
codegen_offloaded_tasks                       37 -&gt;    39    +5.4%
codegen_statements                          3180 -&gt;  3163    -0.5%
codegen_kernel_statements                   2820 -&gt;  2789    -1.1%
codegen_evaluator_statements                   0 -&gt;    14    +inf%
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">目前， <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">benchmark</span></code> 仅支持基准测试语句数，不包含时间基准测试，因为它取决于硬件性能，因此如果基准来自另一台计算机则很难进行比较。 我们将在某个时间点购买固定性能的机器作为时间基准服务器。 讨论在: <a class="reference external" href="https://github.com/taichi-dev/taichi/issue/948">https://github.com/taichi-dev/taichi/issue/948</a></p>
</div>
<p>建议 <strong>Pull Request 的作者</strong> 运行回归测试的工作流程是：</p>
<ul class="simple">
<li>在 <code class="docutils literal notranslate"><span class="pre">master</span></code> 分支中运行 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">benchmark</span> <span class="pre">&amp;&amp;</span> <span class="pre">ti</span> <span class="pre">baseline</span></code> 用来保存目前的结果作为基线。</li>
<li>运行 <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">checkout</span> <span class="pre">-b</span> <span class="pre">your-branch-name</span></code> （分支名称）.</li>
<li>尝试解决问题（第一阶段）。</li>
<li>运行 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">benchmark</span> <span class="pre">&amp;&amp;</span> <span class="pre">ti</span> <span class="pre">regression</span></code> 获取结果。</li>
<li>（结果不理想）继续优化直至结果理想。</li>
<li>（结果理想）在合并之前，运行 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">baseline</span></code> 以将第一阶段结果保存为新基线。</li>
<li>继续进行第二，第三阶段，同时以上的工作流程也同样适用。</li>
</ul>
</div>
<div class="section" id="linux-only-trigger-gdb-when-programs-crash">
<h3>程序崩溃时触发GDB（仅限于Linux操作系统）<a class="headerlink" href="#linux-only-trigger-gdb-when-programs-crash" title="永久链接至标题">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Python
ti.set_gdb_trigger(True)

// C++
CoreState::set_trigger_gdb_when_crash(true);

# Shell
export TI_GDB_TRIGGER=1
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">使用 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> <strong>快速定位段错误 (segmentation fault) 和断言错误 (assertion failure)</strong>: 在Taichi 崩溃时，<code class="docutils literal notranslate"><span class="pre">gdb</span></code> 会被触发并附着到当前的线程上。您可能需要输入和 <code class="docutils literal notranslate"><span class="pre">sudo</span></code> 超级用户权限相关的密码来允许 gdb 附着到当前的线程上。再输入 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 之后， 您可以使用 <code class="docutils literal notranslate"><span class="pre">bt</span></code> （<code class="docutils literal notranslate"><span class="pre">backtrace</span></code>）指令检查堆的回溯，从而定位产生错误的代码的具体行数。</p>
</div>
</div>
<div class="section" id="code-coverage">
<span id="coverage"></span><h3>Code coverage<a class="headerlink" href="#code-coverage" title="永久链接至标题">¶</a></h3>
<p>To ensure that our tests covered every situations, we need to have <strong>coverage report</strong>.
That is, to detect how many percent of code lines in is executed in test.</p>
<ul class="simple">
<li>Generally, the higher the coverage percentage is, the stronger our tests are.</li>
<li>When making a PR, we want to <strong>ensure that it comes with corresponding tests</strong>. Or code coverage will decrease.</li>
<li>Code coverage statuses are visible at <a class="reference external" href="https://codecov.io/gh/taichi-dev/taichi">Codecov</a>.</li>
<li>Currently, Taichi is only set up for Python code coverage report, not for C++ yet.</li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ti <span class="nb">test</span> -C       <span class="c1"># run tests and save results to .coverage</span>
coverage report  <span class="c1"># generate a coverage report on terminal output</span>
coverage html    <span class="c1"># generate a HTML form report in htmlcov/index.html</span>
</pre></div>
</div>
</div>
<div class="section" id="interface-system-legacy">
<h3>接口系统（遗留）<a class="headerlink" href="#interface-system-legacy" title="永久链接至标题">¶</a></h3>
<p>打印所有接口和单位</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">print_all_units</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="serialization-legacy">
<h3>序列化（遗留）<a class="headerlink" href="#serialization-legacy" title="永久链接至标题">¶</a></h3>
<p>Taichi的序列化模块可以允许你将对象序列化/反序列化成二进制字符串。</p>
<p>你可以使用 <code class="docutils literal notranslate"><span class="pre">TI_IO</span></code> 宏来显式定义Taichi中必要的字段。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// TI_IO_DEF</span>
<span class="k">struct</span> <span class="n">Particle</span> <span class="p">{</span>
    <span class="n">Vector3f</span> <span class="n">position</span><span class="p">,</span> <span class="n">velocity</span><span class="p">;</span>
    <span class="n">real</span> <span class="n">mass</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>

    <span class="n">TI_IO_DEF</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// TI_IO_DECL</span>
<span class="k">struct</span> <span class="n">Particle</span> <span class="p">{</span>
    <span class="n">Vector3f</span> <span class="n">position</span><span class="p">,</span> <span class="n">velocity</span><span class="p">;</span>
    <span class="n">real</span> <span class="n">mass</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">has_name</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>

    <span class="n">TI_IO_DECL</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">TI_IO</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
        <span class="n">TI_IO</span><span class="p">(</span><span class="n">velocity</span><span class="p">);</span>
        <span class="n">TI_IO</span><span class="p">(</span><span class="n">mass</span><span class="p">);</span>
        <span class="n">TI_IO</span><span class="p">(</span><span class="n">has_name</span><span class="p">);</span>
        <span class="c1">// More flexibility:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">has_name</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TI_IO</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// TI_IO_DEF_VIRT();</span>
</pre></div>
</div>
</div>
<div class="section" id="progress-notification-legacy">
<h3>进展通知（遗留）<a class="headerlink" href="#progress-notification-legacy" title="永久链接至标题">¶</a></h3>
<p>当任务完成或崩溃时，taichi消息传递程序可以将邮件发送到 <code class="docutils literal notranslate"><span class="pre">$TI_MONITOR_EMAIL</span></code> 。 要启用的话：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">taichi.tools</span> <span class="kn">import</span> <span class="n">messenger</span>
<span class="n">messenger</span><span class="o">.</span><span class="n">enable</span><span class="p">(</span><span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-cpp_style"></span><div class="section" id="c-style">
<h2>C++ 代码风格规范<a class="headerlink" href="#c-style" title="永久链接至标题">¶</a></h2>
<p>我们大体上遵循 <a class="reference external" href="https://google.github.io/styleguide/cppguide.html">Google C++ 代码风格规范</a>。</p>
<div class="section" id="naming">
<h3>命名规则<a class="headerlink" href="#naming" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">变量名称应当由小写词语通过下划线连接组成，例如 <code class="docutils literal notranslate"><span class="pre">llvm_context</span></code>。</p>
</li>
<li><p class="first">类和结构体应当由首字母大写的词语组成，例如 <code class="docutils literal notranslate"><span class="pre">CodegenLLVM</span></code>。</p>
</li>
<li><p class="first">请用由 <code class="docutils literal notranslate"><span class="pre">TI</span></code> 开头的形式来命名宏， 例如 <code class="docutils literal notranslate"><span class="pre">TI_INFO</span></code>。</p>
<blockquote>
<div><ul class="simple">
<li>在碰到不可避免的情况以外我们不提倡在代码中使用宏。</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">文件名称应当由小写词语通过下划线连接组成， 例如 <code class="docutils literal notranslate"><span class="pre">ir_printer.cpp</span></code>。</p>
</li>
</ul>
</div>
<div class="section" id="dos">
<h3>提倡的使用方法<a class="headerlink" href="#dos" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>在适当的情况下对局部变量添加 <code class="docutils literal notranslate"><span class="pre">auto</span></code> 关键字。</li>
<li>在必要的情况下添加 <code class="docutils literal notranslate"><span class="pre">override</span></code> 和 <code class="docutils literal notranslate"><span class="pre">const</span></code> 关键字。</li>
</ul>
</div>
<div class="section" id="don-ts">
<h3>不提倡的使用方法<a class="headerlink" href="#don-ts" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">C语言中的既有范式：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">printf</span></code> （请使用 <code class="docutils literal notranslate"><span class="pre">fmtlib::print</span></code>）。</li>
<li><code class="docutils literal notranslate"><span class="pre">new</span></code> 和 <code class="docutils literal notranslate"><span class="pre">free</span></code>。 请使用智能指针（例如 <code class="docutils literal notranslate"><span class="pre">std::unique_ptr,</span> <span class="pre">std::shared_ptr</span></code> ，而不是手动管理所有关系）。</li>
<li><code class="docutils literal notranslate"><span class="pre">printf</span></code> （请使用 <code class="docutils literal notranslate"><span class="pre">fmtlib::print</span></code>）。</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">异常 （我们正在 <strong>移除</strong> Taichi 中所有 C++ 异常的使用）。</p>
</li>
<li><p class="first">前缀成员函数，例如 <code class="docutils literal notranslate"><span class="pre">m_</span></code>, <code class="docutils literal notranslate"><span class="pre">_</span></code> 等。</p>
</li>
<li><p class="first">在构造函数和析构函数中调用虚函数。</p>
</li>
<li><p class="first">空指针 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 应当使用 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>。</p>
</li>
<li><p class="first">在全局环境下使用 <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">std;</span></code> 。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">typedef</span></code>。 应当使用 <code class="docutils literal notranslate"><span class="pre">using</span></code> 。</p>
</li>
</ul>
</div>
<div class="section" id="automatic-code-formatting">
<h3>自动格式化代码<a class="headerlink" href="#automatic-code-formatting" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>请运行 <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">format</span></code></li>
</ul>
</div>
</div>
<span id="document-internal"></span><div class="section" id="internal-designs-wip">
<h2>内部设计（WIP）<a class="headerlink" href="#internal-designs-wip" title="永久链接至标题">¶</a></h2>
<div class="section" id="intermediate-representation">
<h3>中间表示（Intermediate representation）<a class="headerlink" href="#intermediate-representation" title="永久链接至标题">¶</a></h3>
<p>使用 <code class="docutils literal notranslate"><span class="pre">ti.init(print_ir=True)</span></code> 来将中间表示代码输出到控制台。</p>
</div>
<div class="section" id="list-generation-wip">
<h3>表生成<a class="headerlink" href="#list-generation-wip" title="永久链接至标题">¶</a></h3>
<p>Taichi 中的结构 for 循环会以 <strong>并行</strong> 的方式遍历一个稀疏数据结构中的所有活跃元素。 这把“在稀疏数据结构中均匀分配负载到处理器核心上”这一任务变得十分具有挑战性。具体来说，天真地把一个不规则树分片很容易产生数个叶节点数量严重不均衡的分区。</p>
<p>对此，我们的策略是循序渐进地对于每一层生成（对于该层）活跃的 <code class="docutils literal notranslate"><span class="pre">SNode</span></code> 元素的表。这个表的计算将发生在和计算正常计算内核的同一个设备上，并且具体取决于在用户调用 <code class="docutils literal notranslate"><span class="pre">ti.init</span></code> 函数时所提供的 <code class="docutils literal notranslate"><span class="pre">arch</span></code>  参数。</p>
<p>表的生成将会把数据结构的叶节点展平成一维的稠密数组，并因此规避不完整树的不规则性。然后，我们就可以直接在表上调用一个正常的 <strong>并行 for 循环</strong> 。</p>
<p>例如，</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># misc/listgen_demo.py</span>

<span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">print_ir</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">bitmasked</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="n">func</span><span class="p">()</span>
</pre></div>
</div>
<p>以上的代码会生成下面的中间表示（IR）</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$0 = offloaded clear_list S1dense
$1 = offloaded listgen S0root-&gt;S1dense
$2 = offloaded clear_list S2bitmasked
$3 = offloaded listgen S1dense-&gt;S2bitmasked
$4 = offloaded struct_for(S2bitmasked) block_dim=0 {
  &lt;i32 x1&gt; $5 = loop index 0
  print i, $5
}
</pre></div>
</div>
<p>请注意， <code class="docutils literal notranslate"><span class="pre">func</span></code>  的使用会生成以下两个表：</p>
<blockquote>
<div><ul class="simple">
<li>（任务 <code class="docutils literal notranslate"><span class="pre">$0</span></code> 和 <code class="docutils literal notranslate"><span class="pre">$1</span></code>）基于 <code class="docutils literal notranslate"><span class="pre">root</span></code> 节点 （<code class="docutils literal notranslate"><span class="pre">S0</span></code>）的表会生成一个关于 <code class="docutils literal notranslate"><span class="pre">dense</span></code> 节点们（<code class="docutils literal notranslate"><span class="pre">S1</span></code>）的表；</li>
<li>（任务 <code class="docutils literal notranslate"><span class="pre">$2</span></code> 和 <code class="docutils literal notranslate"><span class="pre">$3</span></code>）基于 <code class="docutils literal notranslate"><span class="pre">dense</span></code> 节点们（<code class="docutils literal notranslate"><span class="pre">S1</span></code>）的表会生成一个关于 <code class="docutils literal notranslate"><span class="pre">bitmasked</span></code> 节点们（<code class="docutils literal notranslate"><span class="pre">S2</span></code>）的表。</li>
</ul>
</div></blockquote>
<p>关于 <code class="docutils literal notranslate"><span class="pre">root</span></code> 节点的表总会有且仅有一个元素（实例），所以我们永远不会去清空或者重新生成这个表。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>关于 <code class="docutils literal notranslate"><span class="pre">place</span></code> （叶）节点的表 （比如说，在这个例子里它是 <code class="docutils literal notranslate"><span class="pre">S3</span></code> )，永远不会被生成。相反，我们可以遍历关于这些节点的父节点们的表，并且于每个父节点，我们在不生成额外的表的情况下直接遍历所有 <code class="docutils literal notranslate"><span class="pre">place</span></code> 节点。</p>
<p>这种设计的初衷是去平摊生成表所带来的额外开销。因为去对于每个叶节点（<code class="docutils literal notranslate"><span class="pre">place</span></code> SNode）生成一个表元素会带来过多的开销，并且这些开销极有可能大大超过在叶元素本身上进行的必要的计算。所以，我们选择只生成和这些叶节点的父节点相关的的元素表，这样就能把生成表所带来的开销平摊到多个倒数第二层的 SNode 元素的子元素上。</p>
<p class="last">在上面的例子中，虽然我们有 <code class="docutils literal notranslate"><span class="pre">16</span></code> 个关于 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的实例，但是我们只生成了 <code class="docutils literal notranslate"><span class="pre">4</span></code> 个 <code class="docutils literal notranslate"><span class="pre">bitmasked</span></code> 节点（和 <code class="docutils literal notranslate"><span class="pre">1</span></code> 个 <code class="docutils literal notranslate"><span class="pre">dense</span></code> 节点）。</p>
</div>
</div>
<div class="section" id="code-generation">
<h3>代码生成<a class="headerlink" href="#code-generation" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="statistics">
<h3>统计量<a class="headerlink" href="#statistics" title="永久链接至标题">¶</a></h3>
<p>在某些情况下，在Taichi程序的执行过程中，收集关于内部事件的特定的量化信息是很用帮助的。<code class="docutils literal notranslate"><span class="pre">Statistics</span></code> 类就是为此设计的。</p>
<p>用法：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>#include “taichi/util/statistics.h”

将1.0加到计数器“codegenoffloaded_tasks”上
taichi::stat.add(“codegen_offloaded_tasks”);

// 将“中间表示”中语句的数量加到计数器“codegen_statements”上
taichi::stat.add(“codegen_statements”, irpass::analysis::count_statements(this-&gt;ir));
</pre></div>
</div>
<p>注意键为 <code class="docutils literal notranslate"><span class="pre">std::string</span></code> 而值类型为 <code class="docutils literal notranslate"><span class="pre">double</span></code>。</p>
<p>在Python中使用如下方式来打印出所有的统计量：</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">print_stat</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="why-python-frontend">
<h3>为什么使用Python作为前端语言<a class="headerlink" href="#why-python-frontend" title="永久链接至标题">¶</a></h3>
<p>将Taichi嵌入到 <code class="docutils literal notranslate"><span class="pre">Python</span></code> 中有以下优点：</p>
<ul class="simple">
<li>易于学习。Taichi的语法与Python非常相似。</li>
<li>易于运行。不需要运行前编译（ahead-of-time compilation）。</li>
<li>这样的设计使用户可以重复利用已有的Python基础架构：<ul>
<li>集成开发环境（IDEs）。大部分Python的集成开发环境提供的语法高亮，语法检查和自动补全功能可以用于Taichi。</li>
<li>包管理器（pip）。开发好的Taichi程序可以被简单地提交至 <code class="docutils literal notranslate"><span class="pre">PyPI</span></code> 并且其他用户可以轻松地使用 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 安装它。</li>
<li>现有的包。用户可以很轻松地与其他Python组件（例如 <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> 和 <code class="docutils literal notranslate"><span class="pre">numpy</span></code>）交互。</li>
</ul>
</li>
<li>只要内核主体可以被Python的解析器解析，那么 <code class="docutils literal notranslate"><span class="pre">Python</span></code> 内置的处理抽象语法树（AST）的工具让我们可以做一些奇妙的事情。</li>
</ul>
<p>但是，这样的设计同样存在一些不足之处：</p>
<ul class="simple">
<li>Taichi内核必须能被Python解析器解析。这意味着Taichi的语法不能超出Python的语法范畴。<ul>
<li>例如，访问Taichi张量时，即使张量是0维度的也必须使用索引。如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是0维的，需要使用 <code class="docutils literal notranslate"><span class="pre">x[None]</span> <span class="pre">=</span> <span class="pre">123</span></code> 来给 <code class="docutils literal notranslate"><span class="pre">x</span></code> 中的量赋值。这是因为在Python语法中， <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">123</span></code> 将会将 <code class="docutils literal notranslate"><span class="pre">x</span></code> 本身（而不是它包含的值）设为常数 <code class="docutils literal notranslate"><span class="pre">123</span></code> ，不幸的是，我们无法更改这种行为。</li>
</ul>
</li>
<li>Python的性能相对较为低下。这在使用纯Python脚本初始化较大Taichi张量时会导致一些性能问题。初始化较大张量时必须使用Taichi内核。</li>
</ul>
</div>
</div>
<span id="document-taichicon"></span><div class="section" id="taichicon">
<h2>Taichi 开发者讨论会<a class="headerlink" href="#taichicon" title="永久链接至标题">¶</a></h2>
<p>我们正在举办一系列线上的 <strong>TaichiCon（Taichi 讨论会）</strong> 活动，让开发人员能够聚集在一起，分享他们使用的 Taichi 经验。</p>
<div class="section" id="past-conferences">
<h3>历届讨论会<a class="headerlink" href="#past-conferences" title="永久链接至标题">¶</a></h3>
<p>历届讨论会的所有相关资料都可以在 <a class="reference external" href="https://github.com/taichi-dev/taichicon">TaichiCon</a> 仓库中找到.</p>
</div>
<div class="section" id="format">
<h3>会议流程<a class="headerlink" href="#format" title="永久链接至标题">¶</a></h3>
<p>目前，每届 TaichiCon 都会包含两个议程： <strong>讲座</strong> 与 <strong>自由讨论</strong>。</p>
<blockquote>
<div><ul class="simple">
<li>最初的一个小时包含了4个10分钟的讲座，每个讲座后留有5分钟的问答时间;</li>
<li>在所有正式的讲座结束之后，与会者可以自由讨论 Taichi 相关的各个方面。</li>
</ul>
</div></blockquote>
<p>讨论会的流程以后也许会有所更动。</p>
</div>
<div class="section" id="language">
<h3>会议语言<a class="headerlink" href="#language" title="永久链接至标题">¶</a></h3>
<p>第 <code class="docutils literal notranslate"><span class="pre">i</span></code> 届 TaichiCon 的主持语言将会使用</p>
<blockquote>
<div><ul class="simple">
<li>英语 <code class="docutils literal notranslate"><span class="pre">(if</span> <span class="pre">i</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">1)</span></code>;</li>
<li>汉语（普通话） <code class="docutils literal notranslate"><span class="pre">(if</span> <span class="pre">i</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0)</span></code>.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="time-and-frequency">
<h3>会议时间及频率<a class="headerlink" href="#time-and-frequency" title="永久链接至标题">¶</a></h3>
<p>Taichi 开发者分散在世界各地，所以选择一个合适的时间让不同时区的人都能够顺利参会是很重要的。</p>
<p>对位于亚洲和美国的开发者来讲，比较合适的时间是:</p>
<blockquote>
<div><ul class="simple">
<li>(中国, 北京) 周日 10:00 - 11:00</li>
<li>(日本, 东京) 周日 11:00 - 12:00</li>
<li>(新西兰, 惠灵顿) 周日 14:00 - 15:00</li>
<li>(美国, 东海岸) 周六 22:00 - 23:00</li>
<li>(美国, 西海岸) 周六 19:00 - 20:00</li>
</ul>
</div></blockquote>
<p>对位于欧洲的开发者来说，我们也许需要调整到一个更合适的时间。可能没有一个完美的解决方案，所以为了给世界各地的开发者们提供平等的时机，TaichiCons 选择了不同的时间段是很有道理的。</p>
<p>TaichiCon 将会大约每月举办一次。</p>
</div>
<div class="section" id="attending-taichicon">
<h3>参加 TaichiCon<a class="headerlink" href="#attending-taichicon" title="永久链接至标题">¶</a></h3>
<p>欢迎每一位对 Taichi 或相关主题（计算机图形学、编译器、高性能计算、计算流体动力学等）感兴趣的人士参与!</p>
<p>Zoom 会议室可容纳300人。一些注意事项:</p>
<blockquote>
<div><ul class="simple">
<li>建议将你在 Zoom 的与会名称修改为统一格式 <code class="docutils literal notranslate"><span class="pre">姓名</span> <span class="pre">(组织)</span></code> 。例如，<code class="docutils literal notranslate"><span class="pre">Yuanming</span> <span class="pre">Hu</span> <span class="pre">(MIT</span> <span class="pre">CSAIL)</span></code>;</li>
<li>请在其他人发言过程中保持静音，以避免背景噪声干扰;</li>
<li>如果你有问题想要提问，请随意在聊天窗口提出;</li>
<li>会议结束后将上传会议录屏和幻灯片;</li>
<li>与会者在参与 TaichiCon 期间通常不应打开摄像头，这可以为处于不理想网络条件下的其他与会者节省网络带宽。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="preparing-for-a-talk-at-taichicon">
<h3>为 TaichiCon 准备讲座<a class="headerlink" href="#preparing-for-a-talk-at-taichicon" title="永久链接至标题">¶</a></h3>
<p>我们欢迎任何有关 Taichi 的话题，包括但不限于</p>
<blockquote>
<div><ul class="simple">
<li>API 建议相关（例如，“我认为 <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> 类需要重构。以下是我的想法……”）</li>
<li>应用程序相关（例如，“我用 Taichi 写了一个新的流体求解器，想要分享…”）</li>
<li>集成相关（例如，“这是我如何将 Taichi 集成到 Blender …”）</li>
<li>内部设计相关（例如，“如何实现一个新的后端”）</li>
<li>…</li>
</ul>
</div></blockquote>
<p>TaichiCon 每轮发言的主体时间为10分钟，每次发言后，接着5分钟的问答时间。如果一轮发言时间累计超过15分钟，主持人可以中断主讲人发言。</p>
</div>
<div class="section" id="organizing-taichicon">
<h3>组织 TaichiCon<a class="headerlink" href="#organizing-taichicon" title="永久链接至标题">¶</a></h3>
<p>在讨论会开始前需要注意：</p>
<blockquote>
<div><ul class="simple">
<li>为会议选择一个合适的时间;</li>
<li>与主讲人沟通：询问讲座的 <strong>标题</strong>，<strong>摘要</strong>，以及一段简明的 <strong>主讲人介绍</strong>;</li>
<li>在社交网站（Facebook、Twitter、知乎等）进行宣传;</li>
<li>确保在会议开始前10分钟，所有的主讲人都已经在（虚拟）会议室就位;<ul>
<li>如果有主讲人还没到场，试着通过电子邮件提醒他/她参会。</li>
</ul>
</li>
</ul>
</div></blockquote>
<p>讨论会进行时需要注意:</p>
<blockquote>
<div><ul class="simple">
<li>确保 Zoom 会话的全程记录;</li>
<li>记得欢迎大家的出席 :-)</li>
<li>在每轮发言之前，先介绍发言者;</li>
<li>在会议最后，感谢所有的发言者和与会者。</li>
</ul>
</div></blockquote>
<p>讨论会结束后需要注意:</p>
<blockquote>
<div><ul class="simple">
<li>将视频上传到 Youtube 和 Bilibili;</li>
<li>收集发言者 PDF 格式的幻灯片;<ul>
<li>使用每轮发言的首页幻灯片截图制作一张概览图;</li>
</ul>
</li>
<li>按照第0届 TaichiCon 的汇总形式更新 <a class="reference external" href="https://github.com/taichi-dev/taichicon">TaichiCon</a> 仓库.</li>
<li>如果发现有任何能够改善 TaichiCon 工作流程的环节，请更新本页文档。</li>
</ul>
</div></blockquote>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-gui"></span><div class="section" id="gui-system">
<span id="gui"></span><h2>GUI系统<a class="headerlink" href="#gui-system" title="永久链接至标题">¶</a></h2>
<p>Taichi具有内置的GUI系统，可帮助用户可视化结果。</p>
<div class="section" id="create-a-window">
<h3>创建一个窗口<a class="headerlink" href="#create-a-window" title="永久链接至标题">¶</a></h3>
<dl class="function">
<dt id="ti.GUI">
<code class="descclassname">ti.</code><code class="descname">GUI</code><span class="sig-paren">(</span><em>title</em>, <em>res</em>, <em>bgcolor = 0x000000</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.GUI" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>title</strong> – （字符串）窗口标题</li>
<li><strong>res</strong> – （标量或元组）分辨率/窗口大小</li>
<li><strong>bgcolor</strong> – （可选，RGB十六进制）窗口的背景颜色</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">（GUI）对象代表窗口</p>
</td>
</tr>
</tbody>
</table>
<p>创建一个窗口。 如果 <code class="docutils literal notranslate"><span class="pre">res</span></code> 是标量，则宽度将等于高度。</p>
<p>以下代码创建了一个分辨率为 <code class="docutils literal notranslate"><span class="pre">640x360</span></code> 的窗口：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gui</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="p">(</span><span class="s1">&#39;Window Title&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">360</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="gui.show">
<code class="descclassname">gui.</code><code class="descname">show</code><span class="sig-paren">(</span><em>filename = None</em><span class="sig-paren">)</span><a class="headerlink" href="#gui.show" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>gui</strong> – (GUI)窗口对象</li>
<li><strong>filename</strong> – （可选，字符串）请参阅以下注释</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>在屏幕上显示窗口。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>如果指定了 <code class="docutils literal notranslate"><span class="pre">文件名</span></code> ，则屏幕截图将被保存到该名称指定的文件中。 例如，以下将窗口的框架保存到 <code class="docutils literal notranslate"><span class="pre">.png</span></code> 文件中：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">render</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">gui</span><span class="o">.</span><span class="n">set_image</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">gui</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{frame:06d}</span><span class="s1">.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</dd></dl>

</div>
<div class="section" id="paint-on-a-window">
<h3>在窗口上作画<a class="headerlink" href="#paint-on-a-window" title="永久链接至标题">¶</a></h3>
<dl class="function">
<dt id="gui.set_image">
<code class="descclassname">gui.</code><code class="descname">set_image</code><span class="sig-paren">(</span><em>img</em><span class="sig-paren">)</span><a class="headerlink" href="#gui.set_image" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>gui</strong> – (GUI)窗口对象</li>
<li><strong>img</strong> – （numpy 数组或 Taichi 张量）包含图像的张量，请参见下面的注释</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>设置要在窗口上显示的图像。</p>
<p>图像像素由 <code class="docutils literal notranslate"><span class="pre">img[i,</span> <span class="pre">j]</span></code> 的值设定，其中 <code class="docutils literal notranslate"><span class="pre">i</span></code> 表示水平坐标（从左到右）， <code class="docutils literal notranslate"><span class="pre">j</span></code> 表示垂直坐标（从下到上） 。</p>
<p>如果窗口大小是 <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> ，则 <code class="docutils literal notranslate"><span class="pre">img</span></code> 必须是以下之一：</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ti.var(shape=(x,</span> <span class="pre">y))</span></code> ，灰度图像</li>
<li><code class="docutils literal notranslate"><span class="pre">ti.var(shape=(x,</span> <span class="pre">y,</span> <span class="pre">3))</span></code> ，其中 <cite>3</cite> 代表 <code class="docutils literal notranslate"><span class="pre">(r,</span> <span class="pre">g,</span> <span class="pre">b)</span></code> 通道</li>
<li><code class="docutils literal notranslate"><span class="pre">ti.Vector(3,</span> <span class="pre">shape=(x,</span> <span class="pre">y))</span></code> （参见 <a class="reference internal" href="index.html#vector"><span class="std std-ref">向量</span></a>）</li>
<li><code class="docutils literal notranslate"><span class="pre">np.ndarray(shape=(x,</span> <span class="pre">y))</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">np.ndarray(shape=(x,</span> <span class="pre">y,</span> <span class="pre">3))</span></code></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">img</span></code> 的数据类型必须是以下之一：</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">uint8</span></code>，范围 <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">255]</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">uint16</span></code>，范围 <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">65535]</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">uint32</span></code>，范围 <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">4294967295]</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">float32</span></code>，范围 <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">float64</span></code>，范围 <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">When using <code class="docutils literal notranslate"><span class="pre">float32</span></code> or <code class="docutils literal notranslate"><span class="pre">float64</span></code> as the data type,
<code class="docutils literal notranslate"><span class="pre">img</span></code> entries will be clipped into range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code> for display.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="gui.circle">
<code class="descclassname">gui.</code><code class="descname">circle</code><span class="sig-paren">(</span><em>pos</em>, <em>color = 0xFFFFFF</em>, <em>radius = 1</em><span class="sig-paren">)</span><a class="headerlink" href="#gui.circle" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>gui</strong> – (GUI)窗口对象</li>
<li><strong>pos</strong> – （2元组）圆的位置</li>
<li><strong>color</strong> – （可选，RGB十六进制）颜色填充圆圈</li>
<li><strong>radius</strong> – （可选，标量）圆的半径</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>画一个实心圆。</p>
</dd></dl>

<dl class="function">
<dt id="gui.circles">
<code class="descclassname">gui.</code><code class="descname">circles</code><span class="sig-paren">(</span><em>pos</em>, <em>color = 0xFFFFFF</em>, <em>radius = 1</em><span class="sig-paren">)</span><a class="headerlink" href="#gui.circles" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>gui</strong> – (GUI)窗口对象</li>
<li><strong>pos</strong> – （numpy 数组）一系列圆的位置</li>
<li><strong>color</strong> – （可选，RGB十六进制或 uint32 的 numpy 数组）颜色以填充圆圈</li>
<li><strong>radius</strong> – （可选，float32的标量或np.array）圆的半径（半径）</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>画多个实心圆。</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果 <code class="docutils literal notranslate"><span class="pre">color</span></code> 是一个 numpy 数组，则位于 <code class="docutils literal notranslate"><span class="pre">pos[i]</span></code> 的圆圈将使用 <code class="docutils literal notranslate"><span class="pre">color[i]</span></code> 作为颜色，因此 <code class="docutils literal notranslate"><span class="pre">color</span></code> 的数组长度必须与 <code class="docutils literal notranslate"><span class="pre">pos</span></code> 相同。</p>
</div>
<dl class="function">
<dt id="gui.line">
<code class="descclassname">gui.</code><code class="descname">line</code><span class="sig-paren">(</span><em>begin</em>, <em>end</em>, <em>color = 0xFFFFFF</em>, <em>radius = 1</em><span class="sig-paren">)</span><a class="headerlink" href="#gui.line" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>gui</strong> – (GUI)窗口对象</li>
<li><strong>begin</strong> – （2元组）直线的第一个端点位置</li>
<li><strong>end</strong> – （2元组）直线的第二个端点位置</li>
<li><strong>color</strong> – （可选，RGB十六进制）线条颜色</li>
<li><strong>radius</strong> – （可选，标量）线的宽度</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>画一条线。</p>
</dd></dl>

<dl class="function">
<dt id="gui.triangle">
<code class="descclassname">gui.</code><code class="descname">triangle</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>c</em>, <em>color = 0xFFFFFF</em><span class="sig-paren">)</span><a class="headerlink" href="#gui.triangle" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>gui</strong> – (GUI)窗口对象</li>
<li><strong>a</strong> – （2元组）三角形的第一个端点位置</li>
<li><strong>b</strong> – （2元组）三角形的第二个端点位置</li>
<li><strong>c</strong> – （2元组）三角形的第三个端点位置</li>
<li><strong>color</strong> – （可选，RGB十六进制）填充三角形的颜色</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>画一个实心三角形。</p>
</dd></dl>

<dl class="function">
<dt id="gui.rect">
<code class="descclassname">gui.</code><code class="descname">rect</code><span class="sig-paren">(</span><em>topleft</em>, <em>bottomright</em>, <em>radius = 1</em>, <em>color = 0xFFFFFF</em><span class="sig-paren">)</span><a class="headerlink" href="#gui.rect" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>gui</strong> – (GUI)窗口对象</li>
<li><strong>topleft</strong> – （2元组）矩形的左上角位置</li>
<li><strong>bottomright</strong> – （2元组）矩形的右下角位置</li>
<li><strong>color</strong> – （可选，RGB十六进制）描边线的颜色</li>
<li><strong>radius</strong> – （可选，标量）描边线的宽度</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>画一个空心的矩形。</p>
</dd></dl>

<dl class="function">
<dt id="gui.text">
<code class="descclassname">gui.</code><code class="descname">text</code><span class="sig-paren">(</span><em>content</em>, <em>pos</em>, <em>font_size = 15</em>, <em>color = 0xFFFFFF</em><span class="sig-paren">)</span><a class="headerlink" href="#gui.text" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>gui</strong> – (GUI)窗口对象</li>
<li><strong>content</strong> – (str) the text to draw</li>
<li><strong>pos</strong> – (tuple of 2) the top-left point position of the fonts / texts</li>
<li><strong>font_size</strong> – (optional, scalar) the size of font (in height)</li>
<li><strong>color</strong> – (optional, RGB hex) the foreground color of text</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Draw a line of text on screen.</p>
</dd></dl>

</div>
<div class="section" id="event-processing">
<h3>事件处理<a class="headerlink" href="#event-processing" title="永久链接至标题">¶</a></h3>
<p>每个事件都有一个 <code class="docutils literal notranslate"><span class="pre">key</span></code> 和 <code class="docutils literal notranslate"><span class="pre">type</span></code>。 <code class="docutils literal notranslate"><span class="pre">key</span></code> 是您在键盘或鼠标上按下的键，可以是以下之一：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">ESCAPE</span>  <span class="c1"># Esc</span>
<span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">SHIFT</span>   <span class="c1"># Shift</span>
<span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">LEFT</span>    <span class="c1"># Left Arrow</span>
<span class="s1">&#39;a&#39;</span>            <span class="c1"># we use lowercase for alphabet</span>
<span class="s1">&#39;b&#39;</span>
<span class="o">...</span>
<span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">LMB</span>     <span class="c1"># Left Mouse Button</span>
<span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">RMB</span>     <span class="c1"># Right Mouse Button</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> 是事件的类型，目前只有三种类型的事件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">RELEASE</span>  <span class="c1"># 松开键</span>
<span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">PRESS</span>   <span class="c1"># 按下键</span>
<span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">MOTION</span>   <span class="c1">#鼠标移动</span>
</pre></div>
</div>
<p><em>事件过滤器</em> 是一个由 <code class="docutils literal notranslate"><span class="pre">key</span></code>，<code class="docutils literal notranslate"><span class="pre">type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">key)</span></code> 元组组成的列表，例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 如果按下或释放ESC:</span>
<span class="n">gui</span><span class="o">.</span><span class="n">get_event</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">ESCAPE</span><span class="p">)</span>

<span class="c1"># 如果按下任何键:</span>
<span class="n">gui</span><span class="o">.</span><span class="n">get_event</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">PRESS</span><span class="p">)</span>

<span class="c1"># 如果按ESC或释放SPACE:</span>
<span class="n">gui</span><span class="o">.</span><span class="n">get_event</span><span class="p">((</span><span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">PRESS</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">ESCAPE</span><span class="p">),</span> <span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">RELEASE</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">SPACE</span><span class="p">))</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="gui.running">
<code class="descclassname">gui.</code><code class="descname">running</code><a class="headerlink" href="#gui.running" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>gui</strong> – （GUI）</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">(bool) <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">ti.GUI.EXIT</span></code> event occurred, vice versa</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">ti.GUI.EXIT</span></code> occurs when you click on the close (X) button of a window.
So <code class="docutils literal notranslate"><span class="pre">gui.running</span></code> will obtain <code class="docutils literal notranslate"><span class="pre">False</span></code> when the GUI is being closed.</p>
<p>For example, loop until the close button is clicked:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">gui</span><span class="o">.</span><span class="n">running</span><span class="p">:</span>
    <span class="n">render</span><span class="p">()</span>
    <span class="n">gui</span><span class="o">.</span><span class="n">set_image</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>
    <span class="n">gui</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>You can also close the window by manually setting <code class="docutils literal notranslate"><span class="pre">gui.running</span></code> to <code class="docutils literal notranslate"><span class="pre">False</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">gui</span><span class="o">.</span><span class="n">running</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">gui</span><span class="o">.</span><span class="n">get_event</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">ESCAPE</span><span class="p">):</span>
        <span class="n">gui</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">render</span><span class="p">()</span>
    <span class="n">gui</span><span class="o">.</span><span class="n">set_image</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>
    <span class="n">gui</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="gui.get_event">
<code class="descclassname">gui.</code><code class="descname">get_event</code><span class="sig-paren">(</span><em>a</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#gui.get_event" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>gui</strong> – （GUI）</li>
<li><strong>a</strong> – （可选，事件过滤器）过滤掉匹配的事件</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(bool) 如果没有待处理的事件，返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>，反之亦然</p>
</td>
</tr>
</tbody>
</table>
<p>尝试从队列中弹出事件，并将其存储在 <code class="docutils literal notranslate"><span class="pre">gui.event</span></code> 中。</p>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">gui</span><span class="o">.</span><span class="n">get_event</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Got event, key =&#39;</span><span class="p">,</span> <span class="n">gui</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>例如，循环直到按下ESC：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gui</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="p">(</span><span class="s1">&#39;Title&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">))</span>
<span class="k">while</span> <span class="ow">not</span> <span class="n">gui</span><span class="o">.</span><span class="n">get_event</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">ESCAPE</span><span class="p">):</span>
    <span class="n">gui</span><span class="o">.</span><span class="n">set_image</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">gui</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="gui.get_events">
<code class="descclassname">gui.</code><code class="descname">get_events</code><span class="sig-paren">(</span><em>a</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#gui.get_events" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>gui</strong> – （GUI）</li>
<li><strong>a</strong> – （可选，事件过滤器）过滤掉匹配的事件</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">（生成器）python生成器，请参见下文</p>
</td>
</tr>
</tbody>
</table>
<p>基本上与 <code class="docutils literal notranslate"><span class="pre">gui.get_event</span></code> 相同，只不过它返回一个事件生成器，而不是存储到 <code class="docutils literal notranslate"><span class="pre">gui.event</span></code> 中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">gui</span><span class="o">.</span><span class="n">get_events</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">ESCAPE</span><span class="p">:</span>
        <span class="n">exit</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">SPACE</span><span class="p">:</span>
        <span class="n">do_something</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">LEFT</span><span class="p">]:</span>
        <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="gui.is_pressed">
<code class="descclassname">gui.</code><code class="descname">is_pressed</code><span class="sig-paren">(</span><em>key</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#gui.is_pressed" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>gui</strong> – （GUI）</li>
<li><strong>key</strong> – (事件的 key) 您要检测的键</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(bool) 其中一个键处于按下状态，返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，反之亦然</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>必须与 <code class="docutils literal notranslate"><span class="pre">gui.get_event</span></code> 一起使用，否则将不会更新！ 例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">gui</span><span class="o">.</span><span class="n">get_event</span><span class="p">()</span>  <span class="c1"># must be called before is_pressed</span>
    <span class="k">if</span> <span class="n">gui</span><span class="o">.</span><span class="n">is_pressed</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">LEFT</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Go left!&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">gui</span><span class="o">.</span><span class="n">is_pressed</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Go right!&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="function">
<dt id="gui.get_cursor_pos">
<code class="descclassname">gui.</code><code class="descname">get_cursor_pos</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gui.get_cursor_pos" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>gui</strong> – （GUI）</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">（2元组）窗口中的当前光标位置</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mouse_x</span><span class="p">,</span> <span class="n">mouse_y</span> <span class="o">=</span> <span class="n">gui</span><span class="o">.</span><span class="n">get_cursor_pos</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="image-i-o">
<h3>图片输入/输出<a class="headerlink" href="#image-i-o" title="永久链接至标题">¶</a></h3>
<dl class="function">
<dt id="ti.imwrite">
<code class="descclassname">ti.</code><code class="descname">imwrite</code><span class="sig-paren">(</span><em>img</em>, <em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.imwrite" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> – (Matrix or Expr) the image you want to export</li>
<li><strong>filename</strong> – (string) the location you want to save to</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Export a <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> or Taichi tensor (<code class="docutils literal notranslate"><span class="pre">ti.Matrix</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.Vector</span></code>, or <code class="docutils literal notranslate"><span class="pre">ti.var</span></code>) to a specified location <code class="docutils literal notranslate"><span class="pre">filename</span></code>.</p>
<p>Same as <code class="docutils literal notranslate"><span class="pre">ti.GUI.show(filename)</span></code>, the format of the exported image is determined by <strong>the suffix of</strong> <code class="docutils literal notranslate"><span class="pre">filename</span></code> as well. Now <code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code> supports exporting images to <code class="docutils literal notranslate"><span class="pre">png</span></code>, <code class="docutils literal notranslate"><span class="pre">img</span></code> and <code class="docutils literal notranslate"><span class="pre">jpg</span></code> and we recommend using <code class="docutils literal notranslate"><span class="pre">png</span></code>.</p>
<p>Please make sure that the input image has <strong>a valid shape</strong>. If you want to export a grayscale image, the input shape of tensor should be <code class="docutils literal notranslate"><span class="pre">(height,</span> <span class="pre">weight)</span></code> or <code class="docutils literal notranslate"><span class="pre">(height,</span> <span class="pre">weight,</span> <span class="pre">1)</span></code>. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>
<span class="nb">type</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">u8</span>
<span class="n">pixels</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">draw</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
        <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">255</span>    <span class="c1"># integars between [0, 255] for ti.u8</span>

<span class="n">draw</span><span class="p">()</span>

<span class="n">ti</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;export_u8.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Besides, for RGB or RGBA images, <code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code> needs to receive a tensor which has shape <code class="docutils literal notranslate"><span class="pre">(height,</span> <span class="pre">width,</span> <span class="pre">3)</span></code> and <code class="docutils literal notranslate"><span class="pre">(height,</span> <span class="pre">width,</span> <span class="pre">4)</span></code> individually.</p>
<p>Generally the value of the pixels on each channel of a <code class="docutils literal notranslate"><span class="pre">png</span></code> image is an integar in [0, 255]. For this reason, <code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code> will <strong>cast tensors</strong> which has different datatypes all <strong>into integars between [0, 255]</strong>. As a result, <code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code> has the following requirements for different datatypes of input tensors:</p>
<ul class="simple">
<li>For float-type (<code class="docutils literal notranslate"><span class="pre">ti.f16</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.f32</span></code>, etc) input tensors, <strong>the value of each pixel should be float between [0.0, 1.0]</strong>. Otherwise <code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code> will first clip them into [0.0, 1.0]. Then they are multiplied by 256 and casted to integaters ranging from [0, 255].</li>
<li>For int-type (<code class="docutils literal notranslate"><span class="pre">ti.u8</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.u16</span></code>, etc) input tensors, <strong>the value of each pixel can be any valid integer in its own bounds</strong>. These integers in this tensor will be scaled to [0, 255] by being divided over the upper bound of its basic type accordingly.</li>
</ul>
<p>Here is another example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>
<span class="n">channels</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nb">type</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span>
<span class="n">pixels</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">draw</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">channels</span><span class="p">)):</span>
            <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>   <span class="c1"># floats between [0, 1] for ti.f32</span>

<span class="n">draw</span><span class="p">()</span>

<span class="n">ti</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;export_f32.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ti.imread">
<code class="descclassname">ti.</code><code class="descname">imread</code><span class="sig-paren">(</span><em>filename</em>, <em>channels=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.imread" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> – (string) the filename of the image to load</li>
<li><strong>channels</strong> – (optional int) the number of channels in your specified image. The default value <code class="docutils literal notranslate"><span class="pre">0</span></code> means the channels of the returned image is adaptive to the image file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(np.ndarray) the image read from <code class="docutils literal notranslate"><span class="pre">filename</span></code></p>
</td>
</tr>
</tbody>
</table>
<p>This function loads an image from the target filename and returns it as a <code class="docutils literal notranslate"><span class="pre">np.ndarray(dtype=np.uint8)</span></code>.</p>
<p>Each value in this returned tensor is an integer in [0, 255].</p>
</dd></dl>

<dl class="function">
<dt id="ti.imshow">
<code class="descclassname">ti.</code><code class="descname">imshow</code><span class="sig-paren">(</span><em>img</em>, <em>windname</em><span class="sig-paren">)</span><a class="headerlink" href="#ti.imshow" title="永久链接至目标">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> – (Matrix or Expr) the image to show in the GUI</li>
<li><strong>windname</strong> – (string) the name of the GUI window</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function will create an instance of <code class="docutils literal notranslate"><span class="pre">ti.GUI</span></code> and show the input image on the screen.</p>
<p>It has the same logic as <code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code> for different datatypes.</p>
</dd></dl>

</div>
</div>
<span id="document-cli_utilities"></span><div class="section" id="command-line-utilities">
<h2>Command line utilities<a class="headerlink" href="#command-line-utilities" title="永久链接至标题">¶</a></h2>
<p>A successful installation of Taichi should add a CLI (Command-Line Interface) to your system,
which is helpful to perform several rountine tasks quickly. To invoke the CLI, please
run <code class="docutils literal notranslate"><span class="pre">ti</span></code> or <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">-m</span> <span class="pre">taichi</span></code>.</p>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h3>
<p>Taichi provides a set of bundled examples. You could run <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">example</span> <span class="pre">-h</span></code> to print the help
message and get a list of available example names. For instance, to run the basic <cite>fractal</cite>
example, try: <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">example</span> <span class="pre">fractal</span></code> from your shell. (<code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">example</span> <span class="pre">fractal.py</span></code> should also
work)</p>
</div>
<div class="section" id="changelog">
<h3>Changelog<a class="headerlink" href="#changelog" title="永久链接至标题">¶</a></h3>
<p>Sometimes it’s convenient to view the changelog of the current version of Taichi, to do so from
your shell, you could run <code class="docutils literal notranslate"><span class="pre">ti</span> <span class="pre">changelog</span></code>.</p>
</div>
</div>
<span id="document-export_results"></span><div class="section" id="export-your-results">
<h2>导出结果<a class="headerlink" href="#export-your-results" title="永久链接至标题">¶</a></h2>
<p>Taichi 提供的函数可以帮助你以 <strong>图像或视频的形式导出可视化结果</strong> 。本节文档将对它们的使用方法逐步演示。</p>
<div class="section" id="export-images">
<h3>导出图像<a class="headerlink" href="#export-images" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>这里有两种方法可以将程序的可视化结果导出为图像。</li>
<li>第一种也是较简单的方式是使用 <code class="docutils literal notranslate"><span class="pre">ti.GUI</span></code>.</li>
<li>第二种方式是调用一系列相关 Taichi 函数，比如 <code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code>.</li>
</ul>
<div class="section" id="export-images-using-ti-gui-show">
<h4>通过 <code class="docutils literal notranslate"><span class="pre">ti.GUI.show</span></code> 导出图像<a class="headerlink" href="#export-images-using-ti-gui-show" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ti.GUI.show(文件名)</span></code> 不仅可以在屏幕上显示 GUI 画布，还可以将 GUI 中的图像保存到指定的 <code class="docutils literal notranslate"><span class="pre">文件名</span></code> 中。</li>
<li>请注意，图像的格式完全由 <code class="docutils literal notranslate"><span class="pre">文件名</span></code> 里的后缀所决定。</li>
<li>Taichi 现在支持将图片保存为 <code class="docutils literal notranslate"><span class="pre">png</span></code>, <code class="docutils literal notranslate"><span class="pre">jpg</span></code>, 和 <code class="docutils literal notranslate"><span class="pre">bmp</span></code> 格式。</li>
<li>我们建议使用 <code class="docutils literal notranslate"><span class="pre">png</span></code> 格式。例如:</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">pixels</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">u8</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">paint</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
        <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">255</span>

<span class="n">iterations</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">gui</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">GUI</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="n">Random</span> <span class="n">pixels</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>

<span class="c1"># mainloop</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
    <span class="n">paint</span><span class="p">()</span>
    <span class="n">gui</span><span class="o">.</span><span class="n">set_image</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>

    <span class="n">filename</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;frame_{i:05d}.png&#39;</span>   <span class="c1"># 创建带有 png 后缀的文件名</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Frame {i} is recorded in {filename}&#39;</span><span class="p">)</span>
    <span class="n">gui</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>  <span class="c1"># 导出并显示在 GUI 中</span>
</pre></div>
</div>
<ul class="simple">
<li>运行上述代码后，你将在当前文件夹中获得一系列 png 图像。</li>
</ul>
</div>
<div class="section" id="export-images-using-ti-imwrite">
<h4>通过  <code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code> 导出图像<a class="headerlink" href="#export-images-using-ti-imwrite" title="永久链接至标题">¶</a></h4>
<p>如果不想通过调用 <code class="docutils literal notranslate"><span class="pre">ti.GUI.show(文件名)</span></code> 保存图像的话，可以使用 <code class="docutils literal notranslate"><span class="pre">ti.imwrite(文件名)</span></code>。例如:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">pixels</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">u8</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">set_pixels</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
        <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">255</span>

<span class="n">set_pixels</span><span class="p">()</span>
<span class="n">filename</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;imwrite_export.png&#39;</span>
<span class="n">ti</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">pixels</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">filename</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;The image has been saved to {filename}&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code> 可以导出 Taichi 张量 (<code class="docutils literal notranslate"><span class="pre">ti.Matrix</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.Vector</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.var</span></code>) 和 numpy 张量 <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code>.</li>
<li>与之前讲到的 <code class="docutils literal notranslate"><span class="pre">ti.GUI.show(filename)</span></code> 一样, 图像格式 (<code class="docutils literal notranslate"><span class="pre">png</span></code>, <code class="docutils literal notranslate"><span class="pre">jpg</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bmp</span></code>) 依旧由 <code class="docutils literal notranslate"><span class="pre">ti.imwrite(文件名)</span></code> 中 <code class="docutils literal notranslate"><span class="pre">文件名</span></code> 包含的后缀所决定.</li>
<li>同时，得到的图像类型（灰度、RGB 或 RGBA）由 <strong>输入张量的通道数</strong> 决定。即，第三维的长度( <code class="docutils literal notranslate"><span class="pre">tensor.shape[2]</span></code> )。</li>
<li>换言之，形状是 <code class="docutils literal notranslate"><span class="pre">(w,</span> <span class="pre">h)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">(w,</span> <span class="pre">h,</span> <span class="pre">1)</span></code> 的张量会被导出成灰度图。</li>
<li>如果你想导出 <code class="docutils literal notranslate"><span class="pre">RGB</span></code> 或 <code class="docutils literal notranslate"><span class="pre">RGBA</span></code> 的图像，输入的张量形状应该分别是 <code class="docutils literal notranslate"><span class="pre">(w,</span> <span class="pre">h,</span> <span class="pre">3)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">(w,</span> <span class="pre">h,</span> <span class="pre">4)</span></code>。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Taichi 中所有的张量都有自己的数据类型，比如 <code class="docutils literal notranslate"><span class="pre">ti.u8</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ti.f32</span></code>。不同的数据类型会导致 <code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code> 产生不同的输出。请参阅 <a class="reference internal" href="index.html#gui"><span class="std std-ref">GUI system</span></a> 了解更多细节。</p>
</div>
<ul class="simple">
<li>除了 <code class="docutils literal notranslate"><span class="pre">ti.imwrite</span></code> 之外，Taichi 还提供了其他读取和显示图像的辅助函数。在 <a class="reference internal" href="index.html#gui"><span class="std std-ref">GUI system</span></a> 中也会有它们的示例。</li>
</ul>
</div>
</div>
<div class="section" id="export-videos">
<h3>导出视频<a class="headerlink" href="#export-videos" title="永久链接至标题">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Taichi 的视频导出工具依赖于 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code>。如果你的机器上还没有安装 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code>，请按照本节末尾的 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code> 安装说明进行操作。</p>
</div>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ti.VideoManger</span></code> can help you export results in <code class="docutils literal notranslate"><span class="pre">mp4</span></code> or <code class="docutils literal notranslate"><span class="pre">gif</span></code> format. For example,</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">pixels</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">u8</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">paint</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
        <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">255</span>

<span class="n">result_dir</span> <span class="o">=</span> <span class="s2">&quot;./results&quot;</span>
<span class="n">video_manger</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">VideoManager</span><span class="p">(</span><span class="n">output_dir</span><span class="o">=</span><span class="n">result_dir</span><span class="p">,</span> <span class="n">framerate</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">automatic_build</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">paint</span><span class="p">()</span>

    <span class="n">pixels_img</span> <span class="o">=</span> <span class="n">pixels</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">video_manger</span><span class="o">.</span><span class="n">write_frame</span><span class="p">(</span><span class="n">pixels_img</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">Frame {i+1}/50 is recorded&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

<span class="k">print</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Exporting .mp4 and .gif videos...&#39;</span><span class="p">)</span>
<span class="n">video_manger</span><span class="o">.</span><span class="n">make_video</span><span class="p">(</span><span class="n">gif</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">mp4</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;MP4 video is saved to {video_manger.get_output_filename(&quot;.mp4&quot;)}&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;GIF video is saved to {video_manger.get_output_filename(&quot;.gif&quot;)}&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>运行上述代码后，你将在 <code class="docutils literal notranslate"><span class="pre">./results/</span></code> 文件夹中找到输出的视频。</p>
</div>
<div class="section" id="install-ffmpeg">
<h3>安装 ffmpeg<a class="headerlink" href="#install-ffmpeg" title="永久链接至标题">¶</a></h3>
<div class="section" id="install-ffmpeg-on-windows">
<h4>在 Windows 上安装 ffmpeg<a class="headerlink" href="#install-ffmpeg-on-windows" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>从 <a class="reference external" href="https://ffmpeg.org/download.html">ffmpeg</a> 上下载 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code> 存档文件（具体名称为，<code class="docutils literal notranslate"><span class="pre">ffmpeg-2020xxx.zip</span></code>）;</li>
<li>解压存档到指定文件夹中，比如， “D:/YOUR_FFMPEG_FOLDER”;</li>
<li><strong>关键步骤：</strong> 添加路径 <code class="docutils literal notranslate"><span class="pre">D:/YOUR_FFMPEG_FOLDER/bin</span></code> 到环境变量 <code class="docutils literal notranslate"><span class="pre">PATH</span></code> 中;</li>
<li>打开 Windows 下的 <code class="docutils literal notranslate"><span class="pre">cmd</span></code> 或 <code class="docutils literal notranslate"><span class="pre">PowerShell</span></code> ，然后输入下面这行命令来测试你的安装是否成功。 如果 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code> 已经正确安装完毕，那么它的版本信息就会被打印出来。</li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>ffmpeg -version
</pre></div>
</div>
</div>
<div class="section" id="install-ffmpeg-on-linux">
<h4>在 Linux 上安装 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code><a class="headerlink" href="#install-ffmpeg-on-linux" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>大多数 Linux 发行版都会自带 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code> ，所以如果你的机器上已经有了 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code> 命令，那么你就不需要阅读这一部分了。</li>
<li>在 Ubuntu 上安装 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>sudo apt-get update
sudo apt-get install ffmpeg
</pre></div>
</div>
<ul class="simple">
<li>在  CentOS 和 RHEL 上安装 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>sudo yum install ffmpeg ffmpeg-devel
</pre></div>
</div>
<ul class="simple">
<li>在 Arch Linux 上安装 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code>:</li>
</ul>
<ul class="simple">
<li>使用下面这行命令测试你的安装是否成功</li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>ffmpeg -h
</pre></div>
</div>
</div>
<div class="section" id="install-ffmpeg-on-os-x">
<h4>在 OS X 上安装 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code><a class="headerlink" href="#install-ffmpeg-on-os-x" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>在  OS X  上可以通过 <code class="docutils literal notranslate"><span class="pre">homebrew</span></code> 安装 <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code>:</li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>brew install ffmpeg
</pre></div>
</div>
</div>
</div>
<div class="section" id="export-ply-files">
<h3>导出 PLY 文件<a class="headerlink" href="#export-ply-files" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ti.PLYwriter</span></code> 可以帮助你将结果导出为 <code class="docutils literal notranslate"><span class="pre">ply</span></code> 格式。下面是导出一个顶点随机着色的立方体动画中10帧画面的短例,</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">taichi</span> <span class="kn">as</span> <span class="nn">ti</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cpu</span><span class="p">)</span>

<span class="n">num_vertices</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">rgba</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>


<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">place_pos</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">:</span>
        <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>


<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">move_particles</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">:</span>
        <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>


<span class="nd">@ti.kernel</span>
<span class="k">def</span> <span class="nf">fill_rgba</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rgba</span><span class="p">:</span>
        <span class="n">rgba</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span>
            <span class="p">[</span><span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">(),</span> <span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">(),</span> <span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">(),</span> <span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">()])</span>


<span class="n">place_pos</span><span class="p">()</span>
<span class="n">series_prefix</span> <span class="o">=</span> <span class="s2">&quot;example.ply&quot;</span>
<span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">move_particles</span><span class="p">()</span>
    <span class="n">fill_rgba</span><span class="p">()</span>
    <span class="c1"># 当前只支持通过传递单个 np.array 来添加通道</span>
    <span class="c1"># 所以需要转换为 np.ndarray 并且 reshape</span>
    <span class="c1"># 记住使用一个临时变量来存储，这样你就不必再转换回来</span>
    <span class="n">np_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="p">(</span><span class="n">num_vertices</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">np_rgba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rgba</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="p">(</span><span class="n">num_vertices</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="c1"># 创建一个 PLYWriter 对象</span>
    <span class="n">writer</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">PLYWriter</span><span class="p">(</span><span class="n">num_vertices</span><span class="o">=</span><span class="n">num_vertices</span><span class="p">)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_pos</span><span class="p">(</span><span class="n">np_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">np_pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np_pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_rgba</span><span class="p">(</span>
        <span class="n">np_rgba</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">np_rgba</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np_rgba</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">np_rgba</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">export_frame_ascii</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">series_prefix</span><span class="p">)</span>
</pre></div>
</div>
<p>运行上述代码后，你将在当前工作目录中找到 <code class="docutils literal notranslate"><span class="pre">ply</span></code> 文件的输出序列。接下来，我们将 <code class="docutils literal notranslate"><span class="pre">ti.PLYWriter</span></code> 的使用方式分解为4个步骤，并相应的展示一些示例。</p>
<ul class="simple">
<li>设置 <code class="docutils literal notranslate"><span class="pre">ti.PLYWriter</span></code></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># num_vertices 必须是正整数</span>
<span class="c1"># num_faces 是可选的，默认为0</span>
<span class="c1"># face_type 可以是 &quot;tri&quot; 或 &quot;quad&quot;, 默认为 &quot;tri&quot;</span>

<span class="c1"># 在之前的例子中，创建了一个带有1000个顶点和0个三角形面片的写入器(writer)</span>
<span class="n">num_vertices</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">writer</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">PLYWriter</span><span class="p">(</span><span class="n">num_vertices</span><span class="o">=</span><span class="n">num_vertices</span><span class="p">)</span>

<span class="c1"># 在下面的例子中，创建了一个带有20个顶点和5个四边形面片的写入器</span>
<span class="n">writer2</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">PLYWriter</span><span class="p">(</span><span class="n">num_vertices</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">num_faces</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">face_type</span><span class="o">=</span><span class="s2">&quot;quad&quot;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li>添加必需的通道信息</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 一个由四边形面片组成的二维网格</span>
<span class="c1">#     y</span>
<span class="c1">#     |</span>
<span class="c1"># z---/</span>
<span class="c1">#    x</span>
<span class="c1">#         19---15---11---07---03</span>
<span class="c1">#         |    |    |    |    |</span>
<span class="c1">#         18---14---10---06---02</span>
<span class="c1">#         |    |    |    |    |</span>
<span class="c1">#         17---13---19---05---01</span>
<span class="c1">#         |    |    |    |    |</span>
<span class="c1">#         16---12---08---04---00</span>

<span class="n">writer</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">PLYWriter</span><span class="p">(</span><span class="n">num_vertices</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">num_faces</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">face_type</span><span class="o">=</span><span class="s2">&quot;quad&quot;</span><span class="p">)</span>

<span class="c1"># 对于顶点来说，唯一必需的通道信息就是位置,</span>
<span class="c1"># 可以通过向下列函数中传递三个 np.array x,y,z 来添加</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_pos</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

<span class="c1"># 对于面片来说（如果有的话），唯一必需的通道信息是每个面片所包含的顶点索引列表。</span>
<span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="mi">12</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">writer</span><span class="o">.</span><span class="n">add_faces</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li>添加可选的通道信息</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 添加自定义顶点通道信息，输入应该包括一个键(key)，支持的数据类型，np.array格式的数据</span>
<span class="n">vdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_channel</span><span class="p">(</span><span class="s2">&quot;vdata1&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">vdata</span><span class="p">)</span>

<span class="c1"># 添加自定义面片通道信息</span>
<span class="n">foo_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="n">writer</span><span class="o">.</span><span class="n">add_face_channel</span><span class="p">(</span><span class="s2">&quot;foo_key&quot;</span><span class="p">,</span> <span class="s2">&quot;foo_data_type&quot;</span><span class="p">,</span> <span class="n">foo_data</span><span class="p">)</span>
<span class="c1"># 错误! 因为 &quot;foo_data_type&quot; 并不是支持的数据类型. 支持的数据类型有如下</span>
<span class="c1"># [&#39;char&#39;, &#39;uchar&#39;, &#39;short&#39;, &#39;ushort&#39;, &#39;int&#39;, &#39;uint&#39;, &#39;float&#39;, &#39;double&#39;]</span>

<span class="c1"># PLYwriter 已经为常用通道定义了几个有用的辅助函数</span>
<span class="c1"># 添加顶点的颜色, alpha通道, 及 rgba</span>
<span class="c1"># 使用 float/double r g b alpha 来表示颜色值, 范围应该在0到1之间</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_color</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
<span class="c1"># 相当于</span>
<span class="c1"># add_vertex_rgba(r, g, b, alpha)</span>

<span class="c1"># 顶点法向</span>
<span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>

<span class="c1"># 顶点索引和块(组内 id)</span>
<span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_id</span><span class="p">()</span>
<span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_piece</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>

<span class="c1"># 添加面片索引和块 (组内 id)</span>
<span class="c1"># 在 writer 中索引已有面片并将其通道信息添加到面片通道信息中</span>
<span class="n">writer</span><span class="o">.</span><span class="n">add_face_id</span><span class="p">()</span>
<span class="c1"># 将所有的面片都放到第一组</span>
<span class="n">writer</span><span class="o">.</span><span class="n">add_face_piece</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
</pre></div>
</div>
<ul class="simple">
<li>导出文件</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">series_prefix</span> <span class="o">=</span> <span class="s2">&quot;example.ply&quot;</span>
<span class="n">series_prefix_ascii</span> <span class="o">=</span> <span class="s2">&quot;example_ascii.ply&quot;</span>
<span class="c1"># 导出一个简单的文件</span>
<span class="c1"># 使用 ascii 编码这样你可以对内容进行概览</span>
<span class="n">writer</span><span class="o">.</span><span class="n">export_ascii</span><span class="p">(</span><span class="n">series_prefix_ascii</span><span class="p">)</span>

<span class="c1"># 或者，使用二进制编码以获得更好的性能</span>
<span class="c1"># writer.export(series_prefix)</span>

<span class="c1"># 导出文件序列，即10帧</span>
<span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># 将每一帧写入你的当前运行的文件夹中( 即， &quot;example_000000.ply&quot;)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">export_frame_ascii</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">series_prefix_ascii</span><span class="p">)</span>
    <span class="c1"># 或者相应的, 使用二进制编码这样写</span>
    <span class="c1"># writer.export_frame(frame, series_prefix)</span>

    <span class="c1"># 更新 位置/颜色</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="c1"># 重新填充</span>
    <span class="n">writer</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">PLYWriter</span><span class="p">(</span><span class="n">num_vertices</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">num_faces</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">face_type</span><span class="o">=</span><span class="s2">&quot;quad&quot;</span><span class="p">)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_pos</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_faces</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_channel</span><span class="p">(</span><span class="s2">&quot;vdata1&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">vdata</span><span class="p">)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_color</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_id</span><span class="p">()</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_vertex_piece</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_face_id</span><span class="p">()</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_face_piece</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
</pre></div>
</div>
<div class="section" id="import-ply-files-into-houdini-and-blender">
<h4>将 <code class="docutils literal notranslate"><span class="pre">ply</span></code> 文件导出到 Houdini 和 Blender<a class="headerlink" href="#import-ply-files-into-houdini-and-blender" title="永久链接至标题">¶</a></h4>
<p>Houdini 支持导入一组共享相同前缀/后缀的 <code class="docutils literal notranslate"><span class="pre">ply</span></code> 文件。我们的 <code class="docutils literal notranslate"><span class="pre">export_frame</span></code> 就可以为你满足这种需求。在 Houdini 中，点击 <code class="docutils literal notranslate"><span class="pre">File-&gt;Import-&gt;Geometry</span></code> 并导航至包含你的框架输出的文件夹中，这些输出结果应该被梳理成一个单一的条目，比如  <code class="docutils literal notranslate"><span class="pre">example_$F6.ply</span> <span class="pre">(0-9)</span></code>。双击该条目以完成导入过程。</p>
<p>Blender 需要一个名为 <a class="reference external" href="https://github.com/neverhood311/Stop-motion-OBJ">Stop-motion-OBJ</a> 的插件来加载结果序列。这里有一个非常详尽的 <a class="reference external" href="https://www.youtube.com/watch?v=Ja7F7WHD39Q">教程视频</a>，是由其作者提供的关于如何安装、授权和使用这个插件的演示。需要注意的一点是，Stop-motion-OBJ 工作流的重大变更是在最近的测试版本中才释放来的。如要跟随他们的说明文档和视频学习和使用，请使用 <code class="docutils literal notranslate"><span class="pre">v2.0.2</span></code> 版本。</p>
</div>
</div>
</div>
<span id="document-global_settings"></span><div class="section" id="global-settings">
<h2>全局设置<a class="headerlink" href="#global-settings" title="永久链接至标题">¶</a></h2>
<div class="section" id="backends">
<h3>后端<a class="headerlink" href="#backends" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>指定要使用的Arch，请执行以下操作： <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_ARCH=cuda</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ti.init(arch=ti.cuda)</span></code>。</li>
<li>指定 CUDA 所使用的 GPU，请执行以下操作：<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">CUDA_VISIBLE_DEVICES=[gpuid]</span></code>。</li>
<li>指定 CUDA 预分配内存的大小：<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_DEVICE_MEMORY_GB=0.5</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ti.init(device_memory_GB=0.5)</span></code>。</li>
<li>禁止 CUDA 使用统一内存： <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_USE_UNIFIED_MEMORY</span> <span class="pre">=</span> <span class="pre">0</span></code>。</li>
</ul>
</div>
<div class="section" id="compilation">
<h3>编译<a class="headerlink" href="#compilation" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>禁用高级优化以节省编译时间和可能的错误：<code class="docutils literal notranslate"><span class="pre">ti.core.toggle_advanced_optimization(False)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_ADVANCED_OPTIMIZATION=0</span></code>。</li>
<li>要打印生成的中间表示码： <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_PRINT_IR=1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ti.init(print_ir=True)</span></code>。</li>
<li>打印预处理后的 Python 代码：<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_PRINT_PREPROCESSED=1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ti.init(print_preprocessed=True)</span></code>。</li>
</ul>
</div>
<div class="section" id="runtime">
<h3>运行<a class="headerlink" href="#runtime" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>重新启动 Taichi 运行系统（销毁所有张量和内核）： <code class="docutils literal notranslate"><span class="pre">ti.reset()</span></code>。</li>
<li>以调试模式启动程序，请执行以下操作： <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_DEBUG=1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ti.init(debug=True)</span></code>。</li>
</ul>
</div>
<div class="section" id="logging">
<h3>日志记录<a class="headerlink" href="#logging" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>通过输出 TRACE 级日志以显示更详尽的信息：<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_LOG_LEVEL=trace</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ti.set_logging_level(ti.TRACE)</span></code>。</li>
<li>消除冗余输出： <code class="docutils literal notranslate"><span class="pre">ti.get_runtime().set_verbose(False)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">TI_VERBOSE=0</span></code>。</li>
</ul>
</div>
<div class="section" id="develop">
<h3>开发<a class="headerlink" href="#develop" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>以 <strong>开发模式</strong> 缓存编译后运行时位码(compiled runtime bitcode)以节省启动时间：<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_CACHE_RUNTIME_BITCODE=1</span></code>。</li>
<li>当 Taichi 崩溃时触发 GDB：<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">TI_GDB_TRIGGER=1</span></code>。</li>
</ul>
</div>
</div>
<span id="document-faq"></span><div class="section" id="frequently-asked-questions">
<h2>Frequently asked questions<a class="headerlink" href="#frequently-asked-questions" title="永久链接至标题">¶</a></h2>
<p><strong>Q:</strong> Can a user iterate over irregular topologies (e.g., graphs or tetrahedral meshes) instead of regular grids?</p>
<p><strong>A:</strong> These structures have to be represented using 1D arrays in Taichi. You can still iterate over them using <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">range(n)</span></code>.
However, at compile time, there’s little the Taichi compiler can do for you to optimize it. You can still tweak the data layout to get different runtime cache behaviors and performance numbers.</p>
</div>
<span id="document-acknowledgments"></span><div class="section" id="acknowledgments">
<h2>致谢<a class="headerlink" href="#acknowledgments" title="永久链接至标题">¶</a></h2>
<p><cite>Taichi</cite> 的实现基于其他开源项目，并且会与 taichi 一起安装，无需用户手动下载： <a class="reference external" href="https://github.com/pybind/pybind11">pybind11</a>, <a class="reference external" href="https://github.com/fmtlib/fmt">fmt</a>, <a class="reference external" href="https://github.com/catchorg/Catch2">Catch2</a>, <a class="reference external" href="https://github.com/gabime/spdlog">spdlog</a>, <a class="reference external" href="https://github.com/nothings/stb">stb_image, stb_image_write, stb_truetype</a>, <a class="reference external" href="https://github.com/syoyo/tinyobjloader">tinyobjloader</a>, <a class="reference external" href="https://www.ffmpeg.org/">ffmpeg</a>, <a class="reference external" href="https://github.com/richgel999/miniz">miniz</a>.</p>
<p><a class="reference external" href="https://halide-lang.org/">Halide</a>  一直以来都是在我们开发中十分有帮助的一个参考库，方便我们了解 Apple Metal 和 LLVM NVPTX 后端的应用程式介面（API），特此致谢。</p>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-legacy_installation"></span><div class="section" id="installing-the-legacy-taichi-library">
<h2>Installing the legacy Taichi Library<a class="headerlink" href="#installing-the-legacy-taichi-library" title="永久链接至标题">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>This is NOT for installing the Taichi programming language. Unless you are building a legacy project
based on the <a class="reference external" href="https://github.com/yuanming-hu/taichi/tree/legacy">legacy Taichi library</a> (e.g.
<a class="reference external" href="https://github.com/yuanming-hu/taichi_mpm">taichi_mpm</a> and
<a class="reference external" href="https://github.com/yuanming-hu/spgrid_topo_opt">spgrid_topo_opt</a>)
you should always install Taichi using <code class="docutils literal notranslate"><span class="pre">pip</span></code>.</p>
<p class="last">If you are working on the Taichi compiler and need to build from source, see <a class="reference internal" href="index.html#dev-install"><span class="std std-ref">Developer installation</span></a>.</p>
</div>
<p>Supported platforms:</p>
<blockquote>
<div><ul class="simple">
<li>Ubuntu (gcc 5+)</li>
<li>Mac OS X (gcc 5+, clang 4.0+)</li>
<li>Windows (Microsoft Visual Studio 2017)</li>
</ul>
</div></blockquote>
<p>Make sure you have <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">3.5</span></code> +.</p>
<div class="section" id="ubuntu-arch-linux-and-mac-os-x">
<h3>Ubuntu, Arch Linux, and Mac OS X<a class="headerlink" href="#ubuntu-arch-linux-and-mac-os-x" title="永久链接至标题">¶</a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget https://raw.githubusercontent.com/yuanming-hu/taichi/legacy/install.py
python3 install.py
</pre></div>
</div>
<p>Note, if python complains that a package is missing, simply rerun install.py and the package should be loaded.</p>
</div>
<div class="section" id="windows">
<h3>Windows<a class="headerlink" href="#windows" title="永久链接至标题">¶</a></h3>
<p>Download and execute <a class="reference external" href="https://raw.githubusercontent.com/yuanming-hu/taichi/legacy/install.py">this script</a> with python3.</p>
<p>Additional environment variables: (assuming taichi is installed in <code class="docutils literal notranslate"><span class="pre">DIR/taichi</span></code>)
Set <code class="docutils literal notranslate"><span class="pre">TAICHI_REPO_DIR</span></code> as  <code class="docutils literal notranslate"><span class="pre">DIR/taichi</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">E:/repos/taichi</span></code>).
Add <code class="docutils literal notranslate"><span class="pre">%TAICHI_REPO_DIR%/python</span></code> to <code class="docutils literal notranslate"><span class="pre">PYTHONPATH</span></code>, <code class="docutils literal notranslate"><span class="pre">DIR/taichi/bin</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">E:/repos/taichi/bin</span></code>) to <code class="docutils literal notranslate"><span class="pre">PATH</span></code>.
Restart cmd or PowerShell, and you should be able to run command <code class="docutils literal notranslate"><span class="pre">ti</span></code>.</p>
</div>
<div class="section" id="build-with-double-precision-64-bit-float-point">
<h3>Build with Double Precision (64 bit) Float Point<a class="headerlink" href="#build-with-double-precision-64-bit-float-point" title="永久链接至标题">¶</a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">TC_USE_DOUBLE</span><span class="o">=</span><span class="m">1</span>
ti build
</pre></div>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Taichi Developers
      
        <span class="commit">
          Revision <code>f69f8493</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/zh_CN/latest/">latest</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="//taichi.readthedocs.io/_/downloads/zh_CN/latest/htmlzip/">html</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="//readthedocs.org/projects/taichi-zh/?fromdocs=taichi-zh">Project Home</a>
          </dd>
          <dd>
            <a href="//readthedocs.org/builds/taichi-zh/?fromdocs=taichi-zh">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org">Read the Docs</a>.

    </div>
  </div>



  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
   

</body>
</html>